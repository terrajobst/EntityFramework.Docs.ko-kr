---
title: 팀 환경의 Code First 마이그레이션-EF6
author: divega
ms.date: 10/23/2016
ms.assetid: 4c2d9a95-de6f-4e97-9738-c1f8043eff69
ms.openlocfilehash: b3c4c35d636caf4ddd251dd78e026587abc57d42
ms.sourcegitcommit: 708b18520321c587b2046ad2ea9fa7c48aeebfe5
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/09/2019
ms.locfileid: "72182607"
---
# <a name="code-first-migrations-in-team-environments"></a>팀 환경에서 Code First 마이그레이션
> [!NOTE]
> 이 문서에서는 기본 시나리오에서 Code First 마이그레이션를 사용 하는 방법을 알고 있다고 가정 합니다. 그렇지 않으면 계속 하기 전에 [Code First 마이그레이션](~/ef6/modeling/code-first/migrations/index.md) 읽어야 합니다.

## <a name="grab-a-coffee-you-need-to-read-this-whole-article"></a>커피를 잡아이 문서 전체를 읽어야 합니다.

팀 환경에서 발생 하는 문제는 주로 두 개발자가 로컬 코드 베이스에서 마이그레이션을 생성 했을 때 마이그레이션을 병합 하는 것입니다. 이를 해결 하는 단계는 매우 간단 하지만 마이그레이션의 작동 방식을 확실 하 게 이해 해야 합니다. 끝으로 건너뛰기-전체 문서를 읽어 성공 했는지 확인 하세요.

## <a name="some-general-guidelines"></a>몇 가지 일반적인 지침

여러 개발자가 생성 한 병합 마이그레이션을 관리 하는 방법에 대해 자세히 살펴보기 전에 성공적인 설치를 위한 몇 가지 일반적인 지침을 제공 합니다.

### <a name="each-team-member-should-have-a-local-development-database"></a>각 팀 멤버에 게는 로컬 개발 데이터베이스가 있어야 합니다.

마이그레이션은 **\_\_MigrationsHistory** 테이블을 사용 하 여 데이터베이스에 적용 된 마이그레이션을 저장 합니다. 동일한 데이터베이스를 대상으로 하 고 **\_\_MigrationsHistory** 테이블)를 공유 하는 동시에 여러 개발자가 서로 다른 마이그레이션을 생성 하는 경우 마이그레이션이 혼란 스 러 울 것입니다.

물론, 마이그레이션을 생성 하지 않는 팀 멤버가 있는 경우에는 중앙 개발 데이터베이스를 공유 하는 데 문제가 없습니다.

### <a name="avoid-automatic-migrations"></a>자동 마이그레이션 방지

아래 줄은 처음에는 팀 환경에서 자동 마이그레이션이 정상적으로 보이지만 실제로는 작동 하지 않습니다. 이유를 알아보려면 읽기를 유지 하 고, 그렇지 않으면 다음 섹션으로 건너뛸 수 있습니다.

자동 마이그레이션을 사용 하면 코드 파일 (코드 기반 마이그레이션)을 생성할 필요 없이 현재 모델과 일치 하도록 데이터베이스 스키마를 업데이트할 수 있습니다. 자동 마이그레이션은 사용한 경우에만 팀 환경에서 매우 잘 작동 하며 코드 기반 마이그레이션을 생성 하지 않습니다. 문제는 자동 마이그레이션이 제한 되어 있고 속성/열 이름 바꾸기, 다른 테이블로 데이터 이동 등의 많은 작업을 처리 하지 않는 것입니다. 이러한 시나리오를 처리 하기 위해 자동 마이그레이션에 의해 처리 되는 변경 내용 간에 혼합 된 코드 기반 마이그레이션 생성 (스 캐 폴드 코드 편집)이 종료 됩니다. 이렇게 하면 두 개발자가 마이그레이션을 체크 인할 때 변경 내용을 병합할 수 없습니다.

## <a name="screencasts"></a>스크린 캐스트

이 문서를 읽는 것 보다 동영상 가이드을 시청 하는 경우 다음 두 비디오는이 문서와 동일한 콘텐츠를 포함 합니다.

### <a name="video-one-migrations---under-the-hood"></a>비디오 1: "마이그레이션-내부"

[이 동영상 가이드](https://channel9.msdn.com/blogs/ef/migrations-under-the-hood) 는 마이그레이션이 모델 변경 내용을 검색 하는 모델에 대 한 정보를 추적 하 고 사용 하는 방법을 설명 합니다.

### <a name="video-two-migrations---team-environments"></a>비디오 2: "마이그레이션-팀 환경"

[이 동영상 가이드](https://channel9.msdn.com/blogs/ef/migrations-team-environments) 는 이전 비디오에서 설명 하는 개념을 기반으로 하 여 팀 환경에서 발생 하는 문제 및 해결 방법에 대해 설명 합니다.

## <a name="understanding-how-migrations-works"></a>마이그레이션 작동 방법 이해

팀 환경에서 마이그레이션을 사용 하기 위한 핵심은 마이그레이션이 모델 변경 내용을 감지 하기 위해 모델에 대 한 정보를 추적 하 고 사용 하는 방법에 대 한 기본적인 개념입니다.

### <a name="the-first-migration"></a>첫 번째 마이그레이션

프로젝트에 첫 번째 마이그레이션을 추가할 때 먼저 패키지 관리자 콘솔에서 **추가 마이그레이션** 과 같은 작업을 실행 합니다. 이 명령이 수행 하는 개략적인 단계는 아래에 나와 있습니다.

![첫 번째 마이그레이션](~/ef6/media/firstmigration.png)

현재 모델은 코드에서 계산 됩니다 (1). 그런 다음 필수 데이터베이스 개체는 모델에 따라 계산 됩니다 (2). 첫 번째 마이그레이션 이므로 모델은 비교를 위해 빈 모델을 사용 하기만 합니다. 필요한 변경 내용을 코드 생성기에 전달 하 여 필요한 마이그레이션 코드 (3)를 빌드한 다음 Visual Studio 솔루션 (4)에 추가 합니다.

마이그레이션은 주 코드 파일에 저장 된 실제 마이그레이션 코드 외에도 몇 가지 추가 코드 파일을 생성 합니다. 이러한 파일은 마이그레이션에 사용 되는 메타 데이터 이며 사용자가 편집 해야 하는 것은 아닙니다. 이러한 파일 중 하나는 마이그레이션이 생성 된 시점의 모델 스냅숏을 포함 하는 리소스 파일 (.resx)입니다. 다음 단계에서이를 사용 하는 방법을 확인할 수 있습니다.

이 시점에서 **업데이트 데이터베이스** 를 실행 하 여 변경 내용을 데이터베이스에 적용 한 다음 응용 프로그램의 다른 영역을 구현 하는 방법에 대해 살펴보겠습니다.

### <a name="subsequent-migrations"></a>후속 마이그레이션

나중에 다시 돌아와서 모델을 약간 변경 합니다 .이 예제에서는 **Url** 속성을 **블로그**에 추가 합니다. 그런 다음 마이그레이션을 스 캐 폴드 **AddUrl** 과 같은 명령을 실행 하 여 해당 하는 데이터베이스 변경 내용을 적용 합니다. 이 명령이 수행 하는 개략적인 단계는 아래에 나와 있습니다.

![두 번째 마이그레이션](~/ef6/media/secondmigration.png)

마지막 시간과 마찬가지로 현재 모델은 코드 (1)에서 계산 됩니다. 그러나 이번에는 기존 마이그레이션이 있으므로 이전 모델은 최신 마이그레이션 (2)에서 검색 됩니다. 이러한 두 모델은 필요한 데이터베이스 변경 (3)을 찾기 위해 차이점을 확인 한 다음 이전 처럼 프로세스를 완료 합니다.

이 프로세스는 프로젝트에 추가 하는 모든 추가 마이그레이션에도 사용 됩니다.

### <a name="why-bother-with-the-model-snapshot"></a>모델 스냅숏이 필요한 이유는 무엇 인가요?

모델 스냅숏으로 EF bothers는 데이터베이스를 단순히 확인 하지 않는 이유를 궁금할 수 있습니다. 그렇다면를 읽어 보십시오. 관심이 없는 경우이 섹션을 건너뛸 수 있습니다.

EF가 모델 스냅숏을 유지 하는 이유는 여러 가지가 있습니다.

-   이를 통해 데이터베이스를 EF 모델에서 드리프트 할 수 있습니다. 이러한 변경 내용은 데이터베이스에서 직접 수행 하거나 마이그레이션의 스 캐 폴드 코드를 변경 하 여 변경할 수 있습니다. 이에 대 한 몇 가지 예는 다음과 같습니다.
    -   삽입 하 고 업데이트 한 열을 하나 이상의 테이블에 추가 하려고 하지만 EF 모델에 이러한 열을 포함 하지 않으려고 합니다. 마이그레이션이 데이터베이스를 살펴보면 마이그레이션을 스 캐 폴드 때마다 이러한 열을 계속 삭제 하려고 시도 합니다. EF는 모델 스냅숏을 사용 하 여 모델에 대 한 합법적인 변경 내용만 검색 합니다.
    -   업데이트에 사용 되는 저장 프로시저의 본문을 변경 하 여 일부 로깅을 포함 하려고 합니다. 마이그레이션이 데이터베이스에서이 저장 프로시저를 살펴본 경우 계속 해 서 EF에서 예상 하는 정의로 다시 설정 합니다. Ef는 모델 스냅숏을 사용 하 여 EF 모델에서 프로시저의 셰이프를 변경 하는 경우에만 저장 프로시저를 변경 하는 코드를 스 캐 폴드 합니다.
    -   이와 동일한 원칙이 데이터베이스의 추가 테이블을 포함 하는 추가 인덱스를 추가 하 고, 테이블에 있는 데이터베이스 뷰에 EF를 매핑하는 등의 추가 인덱스를 추가 하는 경우에도 적용 됩니다.
-   EF 모델에는 데이터베이스의 셰이프만 포함 하 고 있습니다. 전체 모델을 사용 하면 마이그레이션을 통해 모델의 속성 및 클래스에 대 한 정보 및이를 열과 테이블에 매핑하는 방법에 대 한 정보를 볼 수 있습니다. 이 정보를 사용 하면 스 캐 폴드 코드에서 더 지능적으로 마이그레이션할 수 있습니다. 예를 들어 속성이 마이그레이션에 매핑되는 열의 이름을 변경 하면 동일한 속성 (데이터베이스 스키마만 있는 경우에는 수행할 수 없음)을 확인 하 여 이름 바꾸기를 검색할 수 있습니다. 

## <a name="what-causes-issues-in-team-environments"></a>팀 환경에서 발생 하는 문제

이전 섹션에서 다룬 워크플로는 단일 개발자가 응용 프로그램에서 작업 하는 경우에 유용 합니다. 모델을 변경 하는 유일한 사용자 인 경우에도 팀 환경에서 잘 작동 합니다. 이 시나리오에서 모델을 변경 하 고, 마이그레이션을 생성 하 고, 소스 제어에 제출할 수 있습니다. 다른 개발자는 변경 내용을 동기화 하 고 **업데이트 데이터베이스** 를 실행 하 여 스키마 변경을 적용할 수 있습니다.

여러 개발자가 EF 모델을 변경 하 고 동시에 소스 제어에 제출할 때 문제가 발생 하기 시작 합니다. 사용자가 마지막으로 동기화 한 후 다른 개발자가 원본 제어에 제출한 마이그레이션과 로컬 마이그레이션을 병합 하는 첫 번째 클래스 방법이 없다는 것입니다.

## <a name="an-example-of-a-merge-conflict"></a>병합 충돌의 예

먼저 이러한 병합 충돌에 대 한 구체적인 예를 살펴보겠습니다. 앞에서 살펴본 예제를 계속 진행 합니다. 시작 지점으로 이전 섹션의 변경 내용이 원래 개발자에 의해 체크 인 된 것으로 가정 합니다. 코드 베이스를 변경할 때 개발자 두 명의 개발자를 추적 합니다.

몇 가지 변경 내용에 대해 EF 모델 및 마이그레이션을 추적 합니다. 다음 그림에 나와 있는 것 처럼 시작 지점의 경우 두 개발자가 소스 제어 리포지토리에 동기화 되었습니다.

![시작점](~/ef6/media/startingpoint.png)

개발자 \#1 및 developer \#2는 이제 로컬 코드 베이스에서 EF 모델을 변경 합니다. 개발자 \#1은 **등급** 속성을 **블로그에** 추가 하 고, 데이터베이스에 변경 내용을 적용 하는 **addrating** 마이그레이션을 생성 합니다. 개발자 \#2는 **블로그** 에 **Readers** 속성을 추가 하 고 해당 하는 **addreaders** 마이그레이션을 생성 합니다. 두 개발자는 모두 **업데이트 데이터베이스**를 실행 하 여 로컬 데이터베이스에 변경 내용을 적용 한 다음 응용 프로그램 개발을 계속 합니다.

> [!NOTE]
> 마이그레이션에는 타임 스탬프가 접두사로 추가 되기 때문에이 그래픽은 개발자 \#1에서 Addreaders 마이그레이션 후에 개발자 \#2의 AddReaders 마이그레이션이 제공 되었음을 나타냅니다. 개발자 \#1 또는 \#2에서 마이그레이션을 먼저 생성 했는지 여부에 관계 없이 팀에서 작업 하는 문제 또는 다음 섹션에서 볼 수 있도록 병합 하는 프로세스에 차이가 없습니다.

![로컬 변경](~/ef6/media/localchanges.png)

개발자 \#1이 변경 내용을 먼저 제출 하는 것과 같은 1 일이 있습니다. 다른 사용자가 리포지토리를 동기화 한 후 체크 인하지 않았기 때문에 병합을 수행 하지 않고 변경 내용을 전송할 수 있습니다.

![전송](~/ef6/media/submit.png)

이제 개발자 \#2가 제출 하는 시간입니다. 그렇다면 운이 좋은 것은 아닙니다. 다른 사용자가 동기화 된 후에 변경 내용을 전송 했기 때문에 변경 내용을 가져와서 병합 해야 합니다. 소스 제어 시스템은 매우 간단 하므로 코드 수준에서 변경 내용을 자동으로 병합할 수 있습니다. 다음 그림에서는 동기화 후의 개발자 \#2 로컬 리포지토리의 상태를 보여 줍니다. 

![끌어오기](~/ef6/media/pull.png)

이 단계에서 개발자 \#2는 새 **Addrating** 마이그레이션 (개발자 \#2의 데이터베이스에 적용 되지 않은)을 검색 하 고 적용 하는 **업데이트 데이터베이스** 를 실행할 수 있습니다. 이제 **등급** 열이 **블로그** 테이블에 추가 되 고 데이터베이스가 모델과 동기화 됩니다.

하지만 다음과 같은 몇 가지 문제가 있습니다.

1.  **업데이트-데이터베이스** 는 **addrating** 마이그레이션을 적용 하지만 경고를 발생 시킵니다. *보류 중인 변경 내용이 있고 자동 마이그레이션을 사용 하지 않도록 설정 되어 있으므로 현재 모델과 일치 하도록 데이터베이스를 업데이트할 수 없습니다* .
    문제는 마이그레이션이 생성 될 때 모델의 일부가 아니므로 마지막 마이그레이션 (**Addreader** **)에 저장** 된 모델 스냅숏에 **등급** 속성이 누락 되었다는 것입니다. Code First는 마지막 마이그레이션의 모델이 현재 모델과 일치 하지 않음을 감지 하 고 경고를 발생 시킵니다.
2.  응용 프로그램을 실행 하면 " *' BloggingContext ' 컨텍스트를 지 원하는 모델이 데이터베이스를 만든 후에 변경 되었음을 나타내는 InvalidOperationException이 발생 합니다. Code First 마이그레이션를 사용 하 여 데이터베이스를 업데이트 하는 것이 좋습니다. "*
    이 문제는 마지막 마이그레이션에 저장 된 모델 스냅숏이 현재 모델과 일치 하지 않는다는 것입니다.
3.  마지막으로, 이제 **추가 마이그레이션을** 실행 하 게 될 예정입니다. 데이터베이스에 적용 되는 변경 내용이 없기 때문에 이제 빈 마이그레이션이 생성 될 것입니다. 그러나 마이그레이션은 현재 모델을 마지막 마이그레이션 ( **등급** 속성이 누락 됨)의 경우와 비교 하기 때문에 실제로는 **등급** 열에 추가 하는 또 다른 **addcolumn** 호출을 스 캐 폴드 합니다. 물론이 마이그레이션은 **업데이트 데이터베이스** 중에는 **등급** 열이 이미 존재 하기 때문에 실패 합니다.

## <a name="resolving-the-merge-conflict"></a>병합 충돌 해결

좋은 소식은 병합을 수동으로 처리할 필요가 없다는 것입니다. 마이그레이션이 작동 하는 방식을 이해 하 고 있는 것입니다. 따라서이 섹션 앞에서 건너뛴 경우 ... 죄송 합니다. 뒤로 돌아가서 문서의 나머지 부분을 읽어 보세요.

두 가지 옵션이 있습니다. 가장 쉬운 방법은 올바른 현재 모델을 스냅숏으로 포함 하는 빈 마이그레이션을 생성 하는 것입니다. 두 번째 옵션은 올바른 모델 스냅숏을 갖도록 마지막 마이그레이션의 스냅숏을 업데이트 하는 것입니다. 두 번째 옵션은 약간 더 어렵고 모든 시나리오에서 사용할 수 없지만 추가 마이그레이션을 추가 하는 작업이 포함 되지 않기 때문에 클리너입니다.

### <a name="option-1-add-a-blank-merge-migration"></a>옵션 1: 빈 ' 병합 ' 마이그레이션 추가

이 옵션에서는 최신 마이그레이션에 올바른 모델 스냅숏이 저장 되었는지 확인 하기 위해 빈 마이그레이션만 생성 합니다.

이 옵션은 마지막 마이그레이션을 생성 한 사람에 관계 없이 사용할 수 있습니다. 이 예에서는 개발자 \#2가 병합을 처리 하 고 마지막 마이그레이션을 생성 하는 데 참여 했습니다. 하지만 개발자 \#1에서 마지막 마이그레이션을 생성 한 경우에도 이와 동일한 단계를 사용할 수 있습니다. 이러한 단계는 여러 마이그레이션이 관련 된 경우에도 적용 됩니다. 간단 하 게 유지 하기 위해 2를 살펴보겠습니다.

소스 제어에서 동기화 해야 하는 변경 사항이 있는 경우부터 다음 프로세스를이 방법으로 사용할 수 있습니다.

1.  로컬 코드 베이스의 보류 중인 모든 모델 변경 내용이 마이그레이션에 기록 되었는지 확인 합니다. 이 단계를 수행 하면 빈 마이그레이션을 생성할 때 합법적인 변경 사항을 놓치지 않아도 됩니다.
2.  소스 제어와 동기화 합니다.
3.  **업데이트-데이터베이스** 를 실행 하 여 다른 개발자가 체크 인 한 새 마이그레이션을 적용 합니다.
    **_참고:_** *업데이트 데이터베이스 명령에서 경고를 얻지 못한 경우 다른 개발자 로부터 새로운 마이그레이션이 수행 되지 않으므로 추가 병합을 수행할 필요가 없습니다.*
4.  **추가 마이그레이션 &lt;를 실행 하 여\_이름&gt; – IgnoreChanges** (예: **IgnoreChanges**)를\_선택 합니다. 이렇게 하면 모든 메타 데이터 (현재 모델의 스냅숏 포함)를 사용 하 여 마이그레이션이 생성 되지만 마지막 마이그레이션의 스냅숏과 현재 모델을 비교할 때 검색 된 모든 변경 내용은 무시 됩니다.
5.  작업 단위 테스트를 실행 한 후 계속 해 서 개발 하거나 소스 제어에 제출 합니다.

이 방법을 사용한 후의 개발자 \#2 로컬 코드 베이스의 상태는 다음과 같습니다.

![병합 마이그레이션](~/ef6/media/mergemigration.png)

### <a name="option-2-update-the-model-snapshot-in-the-last-migration"></a>옵션 2: 마지막 마이그레이션의 모델 스냅숏 업데이트

이 옵션은 옵션 1과 매우 비슷하며 솔루션에 추가 코드 파일을 사용 하려는 사용자를 위해 추가 빈 마이그레이션이 제거 됩니다.

**이 방법은 최신 마이그레이션이 로컬 코드 베이스에만 존재 하 고 소스 제어에 아직 제출 되지 않은 경우 (예: 병합을 수행 하는 사용자가 마지막 마이그레이션을 생성 한 경우)에만 적합**합니다. 다른 개발자가 이미 개발 데이터베이스에 적용 했을 수 있거나 프로덕션 데이터베이스에 적용 되지 않는 마이그레이션의 메타 데이터를 편집 하는 경우 예기치 않은 부작용이 발생할 수 있습니다. 프로세스 중에 로컬 데이터베이스의 마지막 마이그레이션을 롤백하고 업데이트 된 메타 데이터로 다시 적용 하겠습니다.

마지막 마이그레이션은 로컬 코드 베이스에만 있어야 하지만이를 진행 하는 마이그레이션의 수 또는 순서에는 제한이 없습니다. 여러 다른 개발자의 마이그레이션이 여러 개 있을 수 있으며, 동일한 단계가 적용 됩니다. 간단 하 게 유지 하기 위해 2를 살펴보겠습니다.

소스 제어에서 동기화 해야 하는 변경 사항이 있는 경우부터 다음 프로세스를이 방법으로 사용할 수 있습니다.

1.  로컬 코드 베이스의 보류 중인 모든 모델 변경 내용이 마이그레이션에 기록 되었는지 확인 합니다. 이 단계를 수행 하면 빈 마이그레이션을 생성할 때 합법적인 변경 사항을 놓치지 않아도 됩니다.
2.  원본 제어와 동기화 합니다.
3.  **업데이트-데이터베이스** 를 실행 하 여 다른 개발자가 체크 인 한 새 마이그레이션을 적용 합니다.
    **_참고:_** *업데이트 데이터베이스 명령에서 경고를 얻지 못한 경우 다른 개발자 로부터 새로운 마이그레이션이 수행 되지 않으므로 추가 병합을 수행할 필요가 없습니다.*
4.  **업데이트-데이터베이스-targetmigration &lt;두 번째\_마지막\_마이그레이션&gt;** 를 실행 합니다. 예를 들어 다음 예제에서는 **업데이트-데이터베이스-Targetmigration addrating**입니다. 이렇게 하면 데이터베이스에서 마지막으로 마지막으로 마이그레이션한 후에 데이터베이스의 마지막 마이그레이션 상태가 다시 적용 됩니다.
    **_참고:_** *메타 데이터는 데이터베이스의 \_\_MigrationsHistoryTable에도 저장 되므로 마이그레이션의 메타 데이터를 안전 하 게 편집 하려면이 단계가 필요 합니다. 이것은 마지막 마이그레이션이 로컬 코드 베이스에만 있는 경우에만이 옵션을 사용 해야 하는 이유입니다. 다른 데이터베이스에서 마지막 마이그레이션을 적용 한 경우 해당 데이터베이스를 롤백하고 마지막 마이그레이션을 다시 적용 하 여 메타 데이터를 업데이트 해야 합니다.* 
5.  \_**마지막\_마이그레이션\_의\_타임 스탬프&gt;를 비롯 한 전체\_이름\_&lt;전체 마이그레이션 추가** 를 실행 합니다 (이 예제에서는 다음에 나오는 예제에서는 **추가-마이그레이션 201311062215252\_addreaders**와 같은 것입니다).
    **_참고:_** *새 마이그레이션을 스 캐 폴딩 하지 않고 기존 마이그레이션을 편집 하려고 한다는 것을 알 수 있도록 타임 스탬프를 포함 해야* 합니다.
    그러면 현재 모델과 일치 하도록 마지막 마이그레이션의 메타 데이터가 업데이트 됩니다. 명령이 완료 되 면 다음과 같은 경고가 표시 됩니다 .이는 정확히 원하는 것입니다. " *' 201311062215252\_AddReaders ' 마이그레이션의 디자이너 코드만 다시 스 캐 폴드 되었습니다. 전체 마이그레이션을 다시 스 캐 폴드-Force 매개 변수를 사용 합니다.*
6.  업데이트 **-데이터베이스** 를 실행 하 여 업데이트 된 메타 데이터로 최신 마이그레이션을 다시 적용 합니다.
7.  작업 단위 테스트를 실행 한 후 계속 해 서 개발 하거나 소스 제어에 제출 합니다.

이 방법을 사용한 후의 개발자 \#2 로컬 코드 베이스의 상태는 다음과 같습니다.

![업데이트 된 메타 데이터](~/ef6/media/updatedmetadata.png)

## <a name="summary"></a>요약

팀 환경에서 Code First 마이그레이션를 사용 하는 경우 몇 가지 과제가 있습니다. 그러나 마이그레이션의 작동 원리와 병합 충돌을 해결 하는 몇 가지 간단한 방법에 대 한 기본적인 이해를 통해 이러한 문제를 쉽게 해결할 수 있습니다.

기본 문제는 최신 마이그레이션에 저장 된 잘못 된 메타 데이터입니다. 이로 인해 Code First는 현재 모델 및 데이터베이스 스키마가 일치 하지 않음을 감지 하 고 다음 마이그레이션의 잘못 된 코드를 스 캐 폴드 수 있습니다. 이 상황은 올바른 모델을 사용 하 여 빈 마이그레이션을 생성 하거나 최신 마이그레이션의 메타 데이터를 업데이트 하 여 해결할 수 있습니다.
