---
title: 팀 환경-EF6에서에서 code First 마이그레이션
author: divega
ms.date: 2016-10-23
ms.prod: entity-framework
ms.author: divega
ms.manager: avickers
ms.technology: entity-framework-6
ms.topic: article
ms.assetid: 4c2d9a95-de6f-4e97-9738-c1f8043eff69
caps.latest.revision: 3
ms.openlocfilehash: 6a29fe3ab3aa6b9a51bea54706490f143e860a48
ms.sourcegitcommit: bdd06c9a591ba5e6d6a3ec046c80de98f598f3f3
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 07/10/2018
ms.locfileid: "39122813"
---
# <a name="code-first-migrations-in-team-environments"></a>팀 환경에서 code First 마이그레이션
> [!NOTE]
> 이 문서에서는 기본 시나리오에서 Code First 마이그레이션을 사용 하는 방법을 알고 있다고 가정 합니다. 이렇게 하지 않으면 경우 읽기 해야 [Code First 마이그레이션을](~/ef6/modeling/code-first/migrations/index.md) 계속 하기 전에 합니다.

## <a name="grab-a-coffee-you-need-to-read-this-whole-article"></a>커피이 전체 문서를 참조 해야 합니다.

팀 환경에서 문제를 두 명의 개발자가 로컬 코드 베이스에서 마이그레이션을 생성 하는 경우 마이그레이션 병합 중심 됩니다. 이 해결 하는 단계는 매우 간단한, 해야 마이그레이션을 작동 방식을 이해 해야 합니다. 하세요 없습니다만 끝으로 건너 뛰 세요 – 성공 하도록 전체 문서를 참조 하는 데 시간이 합니다.

## <a name="some-general-guidelines"></a>몇 가지 일반적인 지침

여러 개발자가 생성 하는 병합 마이그레이션을 관리 하는 방법을 살펴보기 전에 성공의 발판을 마련 하는 몇 가지 일반적인 지침 다음과 같습니다.

### <a name="each-team-member-should-have-a-local-development-database"></a>각 팀 멤버에는 로컬 개발 데이터베이스를 사용 해야 합니다.

마이그레이션 사용 합니다  **\_ \_MigrationsHistory** 를 저장할 데이터베이스에 어떤 마이그레이션이 적용 된 테이블입니다. 다른 마이그레이션을 동일한 데이터베이스를 대상으로 하는 동안 생성 하는 여러 개발자가 있는 경우 (및 따라서 공유를  **\_ \_MigrationsHistory** 테이블) 마이그레이션 생기게 것입니다.

물론, 마이그레이션을 생성 하지 않습니다는 팀 멤버에 있는 경우 중앙 개발 데이터베이스를 공유 하도록 생기지 않습니다.

### <a name="avoid-automatic-migrations"></a>자동 마이그레이션 방지

결론은 자동 마이그레이션을 처음 팀 환경에서 적절 한 보이지만 실제로 방금 작동 하지 않는 경우 이유를 계속 읽어 – 하려는 되지 않은 경우, 다음 섹션으로 건너뛸 수 있습니다.

자동 마이그레이션을 사용 하면 코드 파일 (코드 기반 마이그레이션)을 생성 하지 않아도 현재 모델과 일치 하도록 업데이트 하 여 데이터베이스 스키마가 있습니다. 자동 마이그레이션을 작동 하는 매우 잘 팀 환경만 사용 되는 경우 모든 코드 기반 마이그레이션을 생성 되지 않습니다. 문제는 자동 마이그레이션을 제한 되며 다양 한 작업을 처리 하지 않으며 – 속성/열 이름 바꾸기, 다른 테이블에서 데이터 이동 등입니다. 결국 이러한 시나리오를 처리 하도록 코드 기반 마이그레이션을 생성 (및 스 캐 폴드 된 코드 편집) 사이 자동 마이그레이션을 처리 되는 변경 내용을 혼합 되어 있는 합니다. 하기가 거의 불가능에 두 명의 개발자의 마이그레이션을 확인 하는 경우 변경 내용을 병합 합니다.

## <a name="screencasts"></a>스크린 캐스트

이 문서 보다 동영상을 가이드를 보려면 대신는 경우 다음 두 동영상이이 문서와 동일한 콘텐츠를 설명 합니다.

### <a name="video-one-migrations---under-the-hood"></a>비디오 1: "마이그레이션-내부 살펴보기"

[이 스크린 캐스트](http://channel9.msdn.com/blogs/ef/migrations-under-the-hood) 마이그레이션을 추적 하는 방법을 설명 하 고 모델에 대 한 정보를 사용 하 여 모델 변경 내용을 검색 합니다.

### <a name="video-two-migrations---team-environments"></a>비디오 2: "마이그레이션-팀 환경"

이전 비디오에서 개념을 토대로 [이 스크린 캐스트](http://channel9.msdn.com/blogs/ef/migrations-team-environments) 이러한 문제를 해결할 방법과 팀 환경에서 발생 하는 문제를 다룹니다.

## <a name="understanding-how-migrations-works"></a>마이그레이션을 작동 방식 이해

키를 성공적으로 마이그레이션을 사용 하 여 팀 환경에서 마이그레이션을 추적 하는 방법을 이해 하는 기본 하며 모델 변경 내용을 검색 하려면 모델에 대 한 정보를 사용 합니다.

### <a name="the-first-migration"></a>첫 번째 마이그레이션

첫 번째 마이그레이션 프로젝트에 추가할 때 같은 실행할 **Add-migration을 첫 번째** 패키지 관리자 콘솔에서. 이 명령을 수행 하는 대략적인 단계는 아래 그림으로 표시 됩니다.

![FirstMigration](~/ef6/media/firstmigration.png)

현재 모델 (1) 코드에서 계산 됩니다. 필요한 데이터베이스 개체는 모델의 차이점 (2)에서 다음 계산 된 – 첫 번째 마이그레이션 모델 이므로 사용 하 여 비교에 대 한 빈 모델을 다릅니다. 필요한 변경 작업을 Visual Studio 솔루션 (4)에 추가 됩니다는 필요한 마이그레이션 코드 (3)를 빌드하려면 코드 생성기에 전달 됩니다.

기본 코드 파일에 저장 된 실제 마이그레이션 코드 외에도 마이그레이션도 몇 가지 추가 코드 숨김 파일을 생성 합니다. 이러한 파일은 마이그레이션에 사용 되는 메타 데이터 및 편집 해야 하는 항목이 없는 합니다. 이러한 파일 중 하나는 마이그레이션을 생성 된 시간에 모델의 스냅숏을 포함 하는 리소스 파일 (.resx). 다음 단계에서 어떻게 사용 되는지 볼 수 있습니다.

아마도 실행이 시점 **Update-database** 데이터베이스에 변경 내용을 적용 하 여 응용 프로그램의 다른 영역을 구현 하는 방법에 대 한 이동 합니다.

### <a name="subsequent-migrations"></a>이후 마이그레이션

이 예제에서는 추가 복구 되 고 모델에 일부 변경을 수행 – 나중에 **Url** 속성을 **블로그**합니다. 다음 명령을 실행 하와 같은 **Add-migration AddUrl** 해당 데이터베이스에 적용할 마이그레이션을 스 캐 폴딩 변경 합니다. 이 명령을 수행 하는 대략적인 단계는 아래 그림으로 표시 됩니다.

![SecondMigration](~/ef6/media/secondmigration.png)

이전과 마찬가지로, 현재 모델 (1) 코드에서 계산 됩니다. 그러나이 이번 많습니다 기존 마이그레이션 이전 모델 최신 마이그레이션 (2)에서 검색 됩니다. 이러한 두 모델은 필요한 데이터베이스 변경 (3)을 찾으려고의 차이점을 비교 하 고 프로세스가 이전과 같이 완료 합니다.

프로젝트에 추가한 모든 추가 마이그레이션 이와 동일한 프로세스가 사용 됩니다.

### <a name="why-bother-with-the-model-snapshot"></a>모델 스냅숏으로 굳이?

궁금할 EF 모델 스냅숏으로 – 고민 하는 이유는 데이터베이스 뿐 아니라 확인 하는 이유입니다. 그렇다면를 계속 읽어보세요. 관심이 있는 경우이 섹션을 건너뛸 수 있습니다.

EF는 관련 모델 스냅숏을 유지 하는 이유는 여러 가지:

-   데이터베이스를에서 EF 모델 드리프트를 수 있습니다. 데이터베이스에서 직접 변경할 수 있습니다 또는 변경 마이그레이션을 스 캐 폴드 된 코드를 변경할 수 있습니다. 몇 가지 실제로 예는 다음과 같습니다.
    -   테이블의 하나 이상의 열에 삽입 및 업데이트를 추가 하려고 하지만 EF 모델에 이러한 열을 포함 하지 않으려는 합니다. 지속적으로 데이터베이스에 마이그레이션을 검토 하는 경우 마이그레이션을 스 캐 폴드 때마다 이러한 열을 삭제 하려고 합니다. 모델 스냅숏을 사용 하 여, EF만 합법적인 변경 내용을 감지 모델에 있습니다.
    -   업데이트에 대 한 일부 로깅을 포함 하는 데 사용 되는 저장된 프로시저의 본문을 변경 하려고 합니다. 마이그레이션 데이터베이스에서이 저장된 프로시저에서 조회 하는 경우는 지속적으로 시도 하 고 EF 예상 된 정의를 다시 재설정 합니다. 모델 스냅숏을 사용 하 여 EF EF 모델에서 프로시저의 셰이프를 변경 하면 저장된 프로시저를 변경 하는 코드를 스 캐 폴드만 됩니다.
    -   추가 인덱스를 추가, 추가 테이블을 포함 하 여 데이터베이스에서, EF 등 테이블 위에 있는 데이터베이스 뷰에 매핑 이러한 동일한 원칙이 적용 됩니다.
-   EF 모델 데이터베이스의 모양의 이상을 포함합니다. 전체 모델 마이그레이션을 속성 및 클래스 모델 및 테이블 및 열에 매핑하는 방법에 대 한 정보를 살펴볼 수 있습니다. 이 정보에는 마이그레이션을 스 캐 폴딩 하는 코드의 더 지능적인 할 수 있습니다. 예를 들어 마이그레이션에 속성이 매핑되는 열의 이름을 변경 하면 검색할 수 있습니다 하 여 이름 바꾸기 표시 하는 동일한 속성 – 데이터베이스 스키마를 하나만 있는 경우 수행할 수 없는 것입니다. 

## <a name="what-causes-issues-in-team-environments"></a>팀 환경에서 문제 원인

워크플로 응용 프로그램 작업을 단일 개발자의 경우에서 이전 섹션에서는 유용한 설명 합니다. 이 경우에 팀 환경에서 잘 모델을 변경 하는 유일한 사용자. 이 시나리오에서는 모델을 변경, 마이그레이션을 생성 및 소스 제어로 전송할 수 있습니다. 다른 개발자가 변경 내용을 동기화 하 고 실행할 수 **Update-database** 스키마 변경 내용이 적용 해야 합니다.

문제는 여러 개발자가 EF 모델을 변경 하 고 동시에 소스 제어에 제출 해야 하는 경우 발생 하기 시작 합니다. EF에 없는 방법이 첫 번째 클래스는 마지막 동기화 이후 다른 개발자가 소스 제어에 제출 된 마이그레이션과 함께 로컬 마이그레이션을 병합 합니다.

## <a name="an-example-of-a-merge-conflict"></a>병합 충돌의 예

첫 번째 병합 충돌의 구체적인 예를 살펴보겠습니다. 앞에서 살펴본 예제에서 계속 됩니다. 시작 지점으로 보겠습니다 원래 개발자가 이전 섹션의 변경 내용 체크 인 것으로 가정 합니다. 두 명의 개발자 됨에 따라 변경 내용을 코드에 기본 추적 됩니다.

EF 모델 및 다양 한 변경 내용을 통해 마이그레이션을 추적 합니다. 시작 지점에 대 한 개발자는 다음 그림에 표시 된 대로 소스 제어 리포지토리에 동기화 된 합니다.

![StartingPoint](~/ef6/media/startingpoint.png)

개발자 \#1 및 개발자 \#2 이제를 사용 하면 일부 변경 내용이 로컬 코드에서 EF 모델에 기본입니다. 개발자 \#1 추가 **등급** 속성을 **블로그** – 생성을 **AddRating** 마이그레이션 변경 내용을 데이터베이스에 적용할 합니다. 개발자 \#2 추가 된 **판독기** 속성을 **블로그** – 해당 생성 **AddReaders** 마이그레이션. 모두 개발자는 실행할 **Update-database**하는 로컬 데이터베이스에 변경 내용을 적용 하 고 다음 응용 프로그램 개발을 계속 합니다.

> [!NOTE]
> 하므로 그래픽 나타냅니다는 마이그레이션 타임 스탬프를 접두사로 개발자에서 AddReaders 마이그레이션을 \#2 개발자에서 AddRating 마이그레이션 오는 \#1입니다. 여부를 개발자 \#1 또는 \#2 생성 마이그레이션 첫 번째는 팀 또는 다음 섹션에서 살펴보겠습니다 있는 병합 프로세스에서 작업 하는 문제에 차이가 없습니다.

![LocalChanges](~/ef6/media/localchanges.png)

개발자를 위한 운이 일인지 \#1 먼저 해당 변경 내용을 제출 하는 즉시 합니다. 다른 사용자가 체크 인할 해당 리포지토리를 동기화는, 때문에 모든 병합을 수행 하지 않고 변경 사항을 전송할 수 있도록 합니다.

![전송](~/ef6/media/submit.png)

이제 개발자를 위한 \#제출 하는 2입니다. 그다지 운이 되지 않습니다. 이러한 동기화 하므로 다른 사람이 변경 내용을 제출 하기 때문에 풀 다운 된 변경 내용 및 병합 해야 합니다. 소스 제어 시스템 매우 간단한 되므로 코드 수준에서 변경 내용을 자동으로 병합 수 수 있습니다. 개발자의 상태 \#2의 로컬 리포지토리 후 다음 그림에 표시 되어 동기화 합니다. 

![끌어오기](~/ef6/media/pull.png)

이 개발자를 준비 \#2 실행할 수 있습니다 **Update-database** 에서 새 검색 **AddRating** 마이그레이션 (하는 개발자에 게 적용 되지 않았을 \#2의 데이터베이스) 적용 합니다. 이제는 **등급** 열에 추가 되는 **블로그** 테이블 및 데이터베이스 모델을 사용 하 여 동기화 됩니다.

하지만 문제 중 몇 가지 있습니다.

1.  있지만 **Update-database** 적용할 합니다 **AddRating** 경고를 발생 시켜도 마이그레이션: *보류 중인 변경 내용이 있기 때문에 현재 모델과 일치 하도록 데이터베이스를 업데이트할 수 없습니다 및 자동 마이그레이션은 사용 하지 않도록 설정 하는 중...*
    문제가 모델 스냅숏 마지막 마이그레이션을에 저장 된다는 것 (**AddReader**) 누락 되었습니다 합니다 **등급** 속성을 **블로그** (모델에 포함 되지 않은 것 이므로 경우는 마이그레이션 생성). 코드는 먼저 마지막 마이그레이션에서 모델을 현재 모델과 일치 하지 않습니다 하 고 경고를 발생 시킵니다를 검색 합니다.
2.  않는다는 InvalidOperationException 발생 하면 응용 프로그램 실행 "*데이터베이스가 만들어진 후 'BloggingContext' 컨텍스트를 지 원하는 모델이 변경 했습니다. Code First 마이그레이션을 사용 하 여... 데이터베이스를 업데이트 하는 것이 좋습니다 "*
    마찬가지로 문제는 마지막 마이그레이션을에 저장 된 모델 스냅숏 현재 모델과 일치 하지 않습니다.
3.  마지막으로 실행 예상할 **Add-migration** 이제 생성 된 빈 마이그레이션 (데이터베이스에 적용할 변경 하지 않고 있으므로). 마이그레이션 마지막 마이그레이션을에서 하나로 현재 모델을 비교 하기 때문 이지만 (누락 되는 **등급** 속성) 하는 다른 실제로 캐 **AddColumn** 를에추가하는호출이**등급** 열입니다. 물론,이 마이그레이션 중 실패 **Update-database** 때문에 **등급** 열이 이미 있습니다.

## <a name="resolving-the-merge-conflict"></a>병합 충돌 해결

좋은 소식은 아닌지 수동으로 – 병합 처리 하기가 힘든 마이그레이션을 작동 방식을 이해할 수 있게 제공 합니다. 이 섹션에 계속 해 서 생략 한 경우... 죄송 합니다. 돌아가서 나머지 문서 부분을 먼저 읽을 해야!

두 가지 옵션, 빈 마이그레이션을 스냅숏으로 현재 올바른 모델이 생성 하는 가장 쉬운 방법은 것입니다. 두 번째 옵션은 올바른 할 마지막 마이그레이션에 스냅숏을 업데이트 모델 스냅숏. 두 번째 옵션을 약간 더 어렵습니다 이며 모든 시나리오에서 사용할 수 없습니다 하지만 추가 된 추가 마이그레이션이 포함 되어 있지 있으므로 클리너도 됩니다.

### <a name="option-1-add-a-blank-merge-migration"></a>옵션 1: 빈 '병합' 마이그레이션을 추가합니다

빈 마이그레이션 최신 마이그레이션에 있도록 하기 위한 용도로 생성이 옵션에 올바른 모델 스냅숏을 저장 합니다.

이 옵션 사용할 수에 관계 없이 마지막 마이그레이션을 생성 한 합니다. 예제에서는 작업을 수행 했다면 개발자 \#병합 2가 처리 및 발생 마지막 마이그레이션을 생성 합니다. 경우에 이와 동일한 단계를 사용할 수 있습니다 하지만 개발자 \#1 마지막 마이그레이션을 생성 합니다. 단계에서는 방금 보았지만 두에서 간단 하 게 유지 하기 위해 마이그레이션을 여러 건 가지 경우에 적용 됩니다.

소스 제어에서 동기화 되어야 하는 데 필요한 변경 내용이 있는 것을 알게 시간부터 시작 하는이 방식에서는 다음 프로세스를 사용할 수 있습니다.

1.  모든 보류 중인 모델 변경 내용을 로컬 코드 베이스에서 마이그레이션에 기록 되었는지 확인 합니다. 이렇게 하면 빈 마이그레이션 생성할 시기가 되 면 모든 정당한 변경이 놓치지 마세요.
2.  소스 제어와 동기화 합니다.
3.  실행할 **Update-database** 다른 개발자가 체크 인 된 모든 새 마이그레이션을 적용 합니다.
    **
    *참고: * * * Update-database 명령은에서 모든 경고를 얻을 수 없는 다른 개발자 로부터 새 마이그레이션이 있었습니다 고 추가로 병합을 수행할 필요가 없습니다.*
4.  실행 **Add-migration &lt;선택\_는\_이름&gt; – IgnoreChanges** (예를 들어 **Add-migration 병합 – IgnoreChanges**). 이 모든 메타 데이터 (현재 모델의 스냅숏 포함)를 사용 하 여 마이그레이션을 생성 하지만 마지막 마이그레이션에서 스냅숏으로 현재 모델을 비교할 때 검색 될 변경 내용을 무시 합니다 (즉는 빈 값을 가져옵니다 **등록** 및 **다운** 메서드).
5.  개발을 계속 하거나 (물론 테스트 단위 실행) 후 소스 제어에 제출 합니다.

다음은 개발자의 상태 \#2의 로컬이 방법을 사용 하 여 기본 코드입니다.

![MergeMigration](~/ef6/media/mergemigration.png)

### <a name="option-2-update-the-model-snapshot-in-the-last-migration"></a>옵션 2: 마지막 마이그레이션 모델 스냅숏에 업데이트

이 옵션은 옵션 1과 매우 비슷합니다 하지만 때문에 빈 migration – 제거 메시지가 표시 되 면 해당 솔루션에 추가 코드 파일을 하려는 것입니다.

**이 방법은 가능한 최신 마이그레이션을 로컬 코드 베이스에만 존재 하 고 제출 되지 않았습니다 아직 소스 제어에 (예를 들어 경우 마지막 마이그레이션을 병합을 수행 하는 사용자에 의해 생성 된) 경우**합니다. 개발 데이터베이스 – 심지어 다른 개발자가 이미 적용 마이그레이션 메타 데이터 편집 예기치 않은 파생 작업이 발생할 수 있습니다 더 심한 프로덕션 데이터베이스에 적용 합니다. 프로세스 중이 로컬 데이터베이스에서 마지막 마이그레이션을 롤백할 업데이트 된 메타 데이터를 사용 하 여 다시 적용 하는 것이 하겠습니다.

마지막 마이그레이션을 해야 하는 동안 여야 로컬 코드 베이스 수 또는 처리 되는 마이그레이션 순서에 대 한 제한은 없습니다. 여러 다른 개발자 로부터 여러 마이그레이션을 수 및 동일한 단계가 적용 – 우리가 방금 보았지만 두 명에 간단 하 게 유지 하기 위해.

소스 제어에서 동기화 되어야 하는 데 필요한 변경 내용이 있는 것을 알게 시간부터 시작 하는이 방식에서는 다음 프로세스를 사용할 수 있습니다.

1.  모든 보류 중인 모델 변경 내용을 로컬 코드 베이스에서 마이그레이션에 기록 되었는지 확인 합니다. 이렇게 하면 빈 마이그레이션 생성할 시기가 되 면 모든 정당한 변경이 놓치지 마세요.
2.  소스 제어와 동기화 합니다.
3.  실행할 **Update-database** 다른 개발자가 체크 인 된 모든 새 마이그레이션을 적용 합니다.
    **
    *참고: * * * Update-database 명령은에서 모든 경고를 얻을 수 없는 다른 개발자 로부터 새 마이그레이션이 있었습니다 고 추가로 병합을 수행할 필요가 없습니다.*
4.  실행할 **Update-database – TargetMigration &lt;두 번째\_마지막\_마이그레이션&gt;**  (이 예제에서는 수행 됩니다 **-데이터베이스 업데이트 TargetMigration AddRating**). 이 역할이 데이터베이스의 두 번째 상태를 마지막 migration – 효과적으로 '되지 않은 적용' 데이터베이스에서 마지막 마이그레이션입니다.
    **
    *참고: * * *에 메타 데이터도 저장 되므로 마이그레이션 메타 데이터를 편집 하려면 안전 하 게 하려면이 단계는 필요 합니다 \_ \_MigrationsHistoryTable 데이터베이스입니다. 이 때문에 로컬 코드 베이스에 마지막 마이그레이션을 경우만이 옵션을 사용 해야 합니다. 다른 데이터베이스에 적용 된 마지막 마이그레이션이 있으면 해당 사용자에 게 롤백 및 메타 데이터를 업데이트 하려면 마지막 마이그레이션을 다시 적용 해야도 합니다.* 
5.  실행할 **Add-migration &lt;전체\_이름\_포함\_타임 스탬프\_의\_마지막\_마이그레이션** &gt; (예에서 작업을 수행 했다면 것 같이 하는 것 **Add-migration 201311062215252\_AddReaders**).
    **
    *참고: * * * 마이그레이션 새 스 캐 폴딩 하는 것이 아니라 기존 마이그레이션 편집 하려는 알 수 있도록 타임 스탬프를 포함 해야 합니다.*
    이렇게 하면 현재 모델에 맞게 마지막 마이그레이션에 대 한 메타 데이터를 업데이트 됩니다. 명령이 완료 되 면 하지만 이것이 원하는 경우 다음 경고를 얻을 수 있습니다. "*' 201311062215252 마이그레이션에 대 한 디자이너 코드만\_AddReaders' 다시 스 캐 폴드 된 합니다. 사용 하 여 전체 마이그레이션을 스 캐 폴딩 다시를-Force 매개 변수입니다. "*
6.  실행할 **Update-database** 다시 업데이트 된 메타 데이터를 사용 하 여 최신 마이그레이션을 적용 합니다.
7.  개발을 계속 하거나 (물론 테스트 단위 실행) 후 소스 제어에 제출 합니다.

다음은 개발자의 상태 \#2의 로컬이 방법을 사용 하 여 기본 코드입니다.

![UpdatedMetadata](~/ef6/media/updatedmetadata.png)

## <a name="summary"></a>요약

팀 환경에서 Code First 마이그레이션을 사용 하는 경우 몇 가지 과제가 있습니다. 그러나 마이그레이션 작동 원리 및 몇 가지 간단한 접근 방식을 병합 충돌 해결에 대 한 기본적인 이해가 쉽게 이러한 문제를 해결 합니다.

기본적인 문제는 최신 마이그레이션하는 작업에 저장 된 잘못 된 메타 데이터입니다. 이렇게 하면 Code First를 제대로 감지 하지 현재 모델과 데이터베이스 스키마와 일치 하지 않습니다 하는 데 다음 마이그레이션에 잘못 된 코드를 스 캐 폴딩 합니다. 올바른 모델을 사용 하 여 새 마이그레이션을 생성 하거나 최신 마이그레이션에서 메타 데이터를 업데이트 하 여이 이런 문제를 해결할 수 있습니다.
