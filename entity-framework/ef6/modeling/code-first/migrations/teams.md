---
title: 팀 환경의 Code First 마이그레이션-EF6
author: divega
ms.date: 10/23/2016
ms.assetid: 4c2d9a95-de6f-4e97-9738-c1f8043eff69
ms.openlocfilehash: b3c4c35d636caf4ddd251dd78e026587abc57d42
ms.sourcegitcommit: 708b18520321c587b2046ad2ea9fa7c48aeebfe5
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/09/2019
ms.locfileid: "72182607"
---
# <a name="code-first-migrations-in-team-environments"></a><span data-ttu-id="7b944-102">팀 환경에서 Code First 마이그레이션</span><span class="sxs-lookup"><span data-stu-id="7b944-102">Code First Migrations in Team Environments</span></span>
> [!NOTE]
> <span data-ttu-id="7b944-103">이 문서에서는 기본 시나리오에서 Code First 마이그레이션를 사용 하는 방법을 알고 있다고 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-103">This article assumes you know how to use Code First Migrations in basic scenarios.</span></span> <span data-ttu-id="7b944-104">그렇지 않으면 계속 하기 전에 [Code First 마이그레이션](~/ef6/modeling/code-first/migrations/index.md) 읽어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-104">If you don’t, then you’ll need to read [Code First Migrations](~/ef6/modeling/code-first/migrations/index.md) before continuing.</span></span>

## <a name="grab-a-coffee-you-need-to-read-this-whole-article"></a><span data-ttu-id="7b944-105">커피를 잡아이 문서 전체를 읽어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-105">Grab a coffee, you need to read this whole article</span></span>

<span data-ttu-id="7b944-106">팀 환경에서 발생 하는 문제는 주로 두 개발자가 로컬 코드 베이스에서 마이그레이션을 생성 했을 때 마이그레이션을 병합 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-106">The issues in team environments are mostly around merging migrations when two developers have generated migrations in their local code base.</span></span> <span data-ttu-id="7b944-107">이를 해결 하는 단계는 매우 간단 하지만 마이그레이션의 작동 방식을 확실 하 게 이해 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-107">While the steps to solve these are pretty simple, they require you to have a solid understanding of how migrations works.</span></span> <span data-ttu-id="7b944-108">끝으로 건너뛰기-전체 문서를 읽어 성공 했는지 확인 하세요.</span><span class="sxs-lookup"><span data-stu-id="7b944-108">Please don’t just skip ahead to the end – take the time to read the whole article to ensure you are successful.</span></span>

## <a name="some-general-guidelines"></a><span data-ttu-id="7b944-109">몇 가지 일반적인 지침</span><span class="sxs-lookup"><span data-stu-id="7b944-109">Some general guidelines</span></span>

<span data-ttu-id="7b944-110">여러 개발자가 생성 한 병합 마이그레이션을 관리 하는 방법에 대해 자세히 살펴보기 전에 성공적인 설치를 위한 몇 가지 일반적인 지침을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-110">Before we dig into how to manage merging migrations generated by multiple developers, here are some general guidelines to set you up for success.</span></span>

### <a name="each-team-member-should-have-a-local-development-database"></a><span data-ttu-id="7b944-111">각 팀 멤버에 게는 로컬 개발 데이터베이스가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-111">Each team member should have a local development database</span></span>

<span data-ttu-id="7b944-112">마이그레이션은 **\_\_MigrationsHistory** 테이블을 사용 하 여 데이터베이스에 적용 된 마이그레이션을 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-112">Migrations uses the **\_\_MigrationsHistory** table to store what migrations have been applied to the database.</span></span> <span data-ttu-id="7b944-113">동일한 데이터베이스를 대상으로 하 고 **\_\_MigrationsHistory** 테이블)를 공유 하는 동시에 여러 개발자가 서로 다른 마이그레이션을 생성 하는 경우 마이그레이션이 혼란 스 러 울 것입니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-113">If you have multiple developers generating different migrations while trying to target the same database (and thus share a **\_\_MigrationsHistory** table) migrations is going to get very confused.</span></span>

<span data-ttu-id="7b944-114">물론, 마이그레이션을 생성 하지 않는 팀 멤버가 있는 경우에는 중앙 개발 데이터베이스를 공유 하는 데 문제가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-114">Of course, if you have team members that aren’t generating migrations, there is no problem having them share a central development database.</span></span>

### <a name="avoid-automatic-migrations"></a><span data-ttu-id="7b944-115">자동 마이그레이션 방지</span><span class="sxs-lookup"><span data-stu-id="7b944-115">Avoid automatic migrations</span></span>

<span data-ttu-id="7b944-116">아래 줄은 처음에는 팀 환경에서 자동 마이그레이션이 정상적으로 보이지만 실제로는 작동 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-116">The bottom line is that automatic migrations initially look good in team environments, but in reality they just don’t work.</span></span> <span data-ttu-id="7b944-117">이유를 알아보려면 읽기를 유지 하 고, 그렇지 않으면 다음 섹션으로 건너뛸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-117">If you want to know why, keep reading – if not, then you can skip to the next section.</span></span>

<span data-ttu-id="7b944-118">자동 마이그레이션을 사용 하면 코드 파일 (코드 기반 마이그레이션)을 생성할 필요 없이 현재 모델과 일치 하도록 데이터베이스 스키마를 업데이트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-118">Automatic migrations allows you to have your database schema updated to match the current model without the need to generate code files (code-based migrations).</span></span> <span data-ttu-id="7b944-119">자동 마이그레이션은 사용한 경우에만 팀 환경에서 매우 잘 작동 하며 코드 기반 마이그레이션을 생성 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-119">Automatic migrations would work very well in a team environment if you only ever used them and never generated any code-based migrations.</span></span> <span data-ttu-id="7b944-120">문제는 자동 마이그레이션이 제한 되어 있고 속성/열 이름 바꾸기, 다른 테이블로 데이터 이동 등의 많은 작업을 처리 하지 않는 것입니다. 이러한 시나리오를 처리 하기 위해 자동 마이그레이션에 의해 처리 되는 변경 내용 간에 혼합 된 코드 기반 마이그레이션 생성 (스 캐 폴드 코드 편집)이 종료 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-120">The problem is that automatic migrations are limited and don’t handle a number of operations – property/column renames, moving data to another table, etc. To handle these scenarios you end up generating code-based migrations (and editing the scaffolded code) that are mixed in between changes that are handled by automatic migrations.</span></span> <span data-ttu-id="7b944-121">이렇게 하면 두 개발자가 마이그레이션을 체크 인할 때 변경 내용을 병합할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-121">This makes it near on impossible to merge changes when two developers check in migrations.</span></span>

## <a name="screencasts"></a><span data-ttu-id="7b944-122">스크린 캐스트</span><span class="sxs-lookup"><span data-stu-id="7b944-122">Screencasts</span></span>

<span data-ttu-id="7b944-123">이 문서를 읽는 것 보다 동영상 가이드을 시청 하는 경우 다음 두 비디오는이 문서와 동일한 콘텐츠를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-123">If you'd rather watch a screencast than read this article, the following two videos cover the same content as this article.</span></span>

### <a name="video-one-migrations---under-the-hood"></a><span data-ttu-id="7b944-124">비디오 1: "마이그레이션-내부"</span><span class="sxs-lookup"><span data-stu-id="7b944-124">Video One: "Migrations - Under the Hood"</span></span>

<span data-ttu-id="7b944-125">[이 동영상 가이드](https://channel9.msdn.com/blogs/ef/migrations-under-the-hood) 는 마이그레이션이 모델 변경 내용을 검색 하는 모델에 대 한 정보를 추적 하 고 사용 하는 방법을 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-125">[This screencast](https://channel9.msdn.com/blogs/ef/migrations-under-the-hood) covers how migrations tracks and uses information about the model to detect model changes.</span></span>

### <a name="video-two-migrations---team-environments"></a><span data-ttu-id="7b944-126">비디오 2: "마이그레이션-팀 환경"</span><span class="sxs-lookup"><span data-stu-id="7b944-126">Video Two: "Migrations - Team Environments"</span></span>

<span data-ttu-id="7b944-127">[이 동영상 가이드](https://channel9.msdn.com/blogs/ef/migrations-team-environments) 는 이전 비디오에서 설명 하는 개념을 기반으로 하 여 팀 환경에서 발생 하는 문제 및 해결 방법에 대해 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-127">Building on the concepts from the previous video, [this screencast](https://channel9.msdn.com/blogs/ef/migrations-team-environments) covers the issues that arise in a team environment and how to solve them.</span></span>

## <a name="understanding-how-migrations-works"></a><span data-ttu-id="7b944-128">마이그레이션 작동 방법 이해</span><span class="sxs-lookup"><span data-stu-id="7b944-128">Understanding how migrations works</span></span>

<span data-ttu-id="7b944-129">팀 환경에서 마이그레이션을 사용 하기 위한 핵심은 마이그레이션이 모델 변경 내용을 감지 하기 위해 모델에 대 한 정보를 추적 하 고 사용 하는 방법에 대 한 기본적인 개념입니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-129">The key to successfully using migrations in a team environment is a basic understanding how migrations tracks and uses information about the model to detect model changes.</span></span>

### <a name="the-first-migration"></a><span data-ttu-id="7b944-130">첫 번째 마이그레이션</span><span class="sxs-lookup"><span data-stu-id="7b944-130">The first migration</span></span>

<span data-ttu-id="7b944-131">프로젝트에 첫 번째 마이그레이션을 추가할 때 먼저 패키지 관리자 콘솔에서 **추가 마이그레이션** 과 같은 작업을 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-131">When you add the first migration to your project, you run something like **Add-Migration First** in Package Manager Console.</span></span> <span data-ttu-id="7b944-132">이 명령이 수행 하는 개략적인 단계는 아래에 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-132">The high level steps that this command performs are pictured below.</span></span>

![첫 번째 마이그레이션](~/ef6/media/firstmigration.png)

<span data-ttu-id="7b944-134">현재 모델은 코드에서 계산 됩니다 (1).</span><span class="sxs-lookup"><span data-stu-id="7b944-134">The current model is calculated from your code (1).</span></span> <span data-ttu-id="7b944-135">그런 다음 필수 데이터베이스 개체는 모델에 따라 계산 됩니다 (2). 첫 번째 마이그레이션 이므로 모델은 비교를 위해 빈 모델을 사용 하기만 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-135">The required database objects are then calculated by the model differ (2) – since this is the first migration the model differ just uses an empty model for the comparison.</span></span> <span data-ttu-id="7b944-136">필요한 변경 내용을 코드 생성기에 전달 하 여 필요한 마이그레이션 코드 (3)를 빌드한 다음 Visual Studio 솔루션 (4)에 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-136">The required changes are passed to the code generator to build the required migration code (3) which is then added to your Visual Studio solution (4).</span></span>

<span data-ttu-id="7b944-137">마이그레이션은 주 코드 파일에 저장 된 실제 마이그레이션 코드 외에도 몇 가지 추가 코드 파일을 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-137">In addition to the actual migration code that is stored in the main code file, migrations also generates some additional code-behind files.</span></span> <span data-ttu-id="7b944-138">이러한 파일은 마이그레이션에 사용 되는 메타 데이터 이며 사용자가 편집 해야 하는 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-138">These files are metadata that is used by migrations and are not something you should edit.</span></span> <span data-ttu-id="7b944-139">이러한 파일 중 하나는 마이그레이션이 생성 된 시점의 모델 스냅숏을 포함 하는 리소스 파일 (.resx)입니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-139">One of these files is a resource file (.resx) that contains a snapshot of the model at the time the migration was generated.</span></span> <span data-ttu-id="7b944-140">다음 단계에서이를 사용 하는 방법을 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-140">You’ll see how this is used in the next step.</span></span>

<span data-ttu-id="7b944-141">이 시점에서 **업데이트 데이터베이스** 를 실행 하 여 변경 내용을 데이터베이스에 적용 한 다음 응용 프로그램의 다른 영역을 구현 하는 방법에 대해 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-141">At this point you would probably run **Update-Database** to apply your changes to the database, and then go about implementing other areas of your application.</span></span>

### <a name="subsequent-migrations"></a><span data-ttu-id="7b944-142">후속 마이그레이션</span><span class="sxs-lookup"><span data-stu-id="7b944-142">Subsequent migrations</span></span>

<span data-ttu-id="7b944-143">나중에 다시 돌아와서 모델을 약간 변경 합니다 .이 예제에서는 **Url** 속성을 **블로그**에 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-143">Later you come back and make some changes to your model – in our example we’ll add a **Url** property to **Blog**.</span></span> <span data-ttu-id="7b944-144">그런 다음 마이그레이션을 스 캐 폴드 **AddUrl** 과 같은 명령을 실행 하 여 해당 하는 데이터베이스 변경 내용을 적용 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-144">You would then issue a command such as **Add-Migration AddUrl** to scaffold a migration to apply the corresponding database changes.</span></span> <span data-ttu-id="7b944-145">이 명령이 수행 하는 개략적인 단계는 아래에 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-145">The high level steps that this command performs are pictured below.</span></span>

![두 번째 마이그레이션](~/ef6/media/secondmigration.png)

<span data-ttu-id="7b944-147">마지막 시간과 마찬가지로 현재 모델은 코드 (1)에서 계산 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-147">Just like last time, the current model is calculated from code (1).</span></span> <span data-ttu-id="7b944-148">그러나 이번에는 기존 마이그레이션이 있으므로 이전 모델은 최신 마이그레이션 (2)에서 검색 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-148">However, this time there are existing migrations so the previous model is retrieved from the latest migration (2).</span></span> <span data-ttu-id="7b944-149">이러한 두 모델은 필요한 데이터베이스 변경 (3)을 찾기 위해 차이점을 확인 한 다음 이전 처럼 프로세스를 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-149">These two models are diffed to find the required database changes (3) and then the process completes as before.</span></span>

<span data-ttu-id="7b944-150">이 프로세스는 프로젝트에 추가 하는 모든 추가 마이그레이션에도 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-150">This same process is used for any further migrations that you add to the project.</span></span>

### <a name="why-bother-with-the-model-snapshot"></a><span data-ttu-id="7b944-151">모델 스냅숏이 필요한 이유는 무엇 인가요?</span><span class="sxs-lookup"><span data-stu-id="7b944-151">Why bother with the model snapshot?</span></span>

<span data-ttu-id="7b944-152">모델 스냅숏으로 EF bothers는 데이터베이스를 단순히 확인 하지 않는 이유를 궁금할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-152">You may be wondering why EF bothers with the model snapshot – why not just look at the database.</span></span> <span data-ttu-id="7b944-153">그렇다면를 읽어 보십시오.</span><span class="sxs-lookup"><span data-stu-id="7b944-153">If so, read on.</span></span> <span data-ttu-id="7b944-154">관심이 없는 경우이 섹션을 건너뛸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-154">If you’re not interested then you can skip this section.</span></span>

<span data-ttu-id="7b944-155">EF가 모델 스냅숏을 유지 하는 이유는 여러 가지가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-155">There are a number of reasons EF keeps the model snapshot around:</span></span>

-   <span data-ttu-id="7b944-156">이를 통해 데이터베이스를 EF 모델에서 드리프트 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-156">It allows your database to drift from the EF model.</span></span> <span data-ttu-id="7b944-157">이러한 변경 내용은 데이터베이스에서 직접 수행 하거나 마이그레이션의 스 캐 폴드 코드를 변경 하 여 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-157">These changes can be made directly in the database, or you can change the scaffolded code in your migrations to make the changes.</span></span> <span data-ttu-id="7b944-158">이에 대 한 몇 가지 예는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-158">Here are a couple of examples of this in practice:</span></span>
    -   <span data-ttu-id="7b944-159">삽입 하 고 업데이트 한 열을 하나 이상의 테이블에 추가 하려고 하지만 EF 모델에 이러한 열을 포함 하지 않으려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-159">You want to add an Inserted and Updated to column to one or more of your tables but you don’t want to include these columns in the EF model.</span></span> <span data-ttu-id="7b944-160">마이그레이션이 데이터베이스를 살펴보면 마이그레이션을 스 캐 폴드 때마다 이러한 열을 계속 삭제 하려고 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-160">If migrations looked at the database it would continually try to drop these columns every time you scaffolded a migration.</span></span> <span data-ttu-id="7b944-161">EF는 모델 스냅숏을 사용 하 여 모델에 대 한 합법적인 변경 내용만 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-161">Using the model snapshot, EF will only ever detect legitimate changes to the model.</span></span>
    -   <span data-ttu-id="7b944-162">업데이트에 사용 되는 저장 프로시저의 본문을 변경 하 여 일부 로깅을 포함 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-162">You want to change the body of a stored procedure used for updates to include some logging.</span></span> <span data-ttu-id="7b944-163">마이그레이션이 데이터베이스에서이 저장 프로시저를 살펴본 경우 계속 해 서 EF에서 예상 하는 정의로 다시 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-163">If migrations looked at this stored procedure from the database it would continually try and reset it back to the definition that EF expects.</span></span> <span data-ttu-id="7b944-164">Ef는 모델 스냅숏을 사용 하 여 EF 모델에서 프로시저의 셰이프를 변경 하는 경우에만 저장 프로시저를 변경 하는 코드를 스 캐 폴드 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-164">By using the model snapshot, EF will only ever scaffold code to alter the stored procedure when you change the shape of the procedure in the EF model.</span></span>
    -   <span data-ttu-id="7b944-165">이와 동일한 원칙이 데이터베이스의 추가 테이블을 포함 하는 추가 인덱스를 추가 하 고, 테이블에 있는 데이터베이스 뷰에 EF를 매핑하는 등의 추가 인덱스를 추가 하는 경우에도 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-165">These same principles apply to adding extra indexes, including extra tables in your database, mapping EF to a database view that sits over a table, etc.</span></span>
-   <span data-ttu-id="7b944-166">EF 모델에는 데이터베이스의 셰이프만 포함 하 고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-166">The EF model contains more than just the shape of the database.</span></span> <span data-ttu-id="7b944-167">전체 모델을 사용 하면 마이그레이션을 통해 모델의 속성 및 클래스에 대 한 정보 및이를 열과 테이블에 매핑하는 방법에 대 한 정보를 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-167">Having the entire model allows migrations to look at information about the properties and classes in your model and how they map to the columns and tables.</span></span> <span data-ttu-id="7b944-168">이 정보를 사용 하면 스 캐 폴드 코드에서 더 지능적으로 마이그레이션할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-168">This information allows migrations to be more intelligent in the code that it scaffolds.</span></span> <span data-ttu-id="7b944-169">예를 들어 속성이 마이그레이션에 매핑되는 열의 이름을 변경 하면 동일한 속성 (데이터베이스 스키마만 있는 경우에는 수행할 수 없음)을 확인 하 여 이름 바꾸기를 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-169">For example, if you change the name of the column that a property maps to migrations can detect the rename by seeing that it’s the same property – something that can’t be done if you only have the database schema.</span></span> 

## <a name="what-causes-issues-in-team-environments"></a><span data-ttu-id="7b944-170">팀 환경에서 발생 하는 문제</span><span class="sxs-lookup"><span data-stu-id="7b944-170">What causes issues in team environments</span></span>

<span data-ttu-id="7b944-171">이전 섹션에서 다룬 워크플로는 단일 개발자가 응용 프로그램에서 작업 하는 경우에 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-171">The workflow covered in the previous section works great when you are a single developer working on an application.</span></span> <span data-ttu-id="7b944-172">모델을 변경 하는 유일한 사용자 인 경우에도 팀 환경에서 잘 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-172">It also works well in a team environment if you are the only person making changes to the model.</span></span> <span data-ttu-id="7b944-173">이 시나리오에서 모델을 변경 하 고, 마이그레이션을 생성 하 고, 소스 제어에 제출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-173">In this scenario you can make model changes, generate migrations and submit them to your source control.</span></span> <span data-ttu-id="7b944-174">다른 개발자는 변경 내용을 동기화 하 고 **업데이트 데이터베이스** 를 실행 하 여 스키마 변경을 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-174">Other developers can sync your changes and run **Update-Database** to have the schema changes applied.</span></span>

<span data-ttu-id="7b944-175">여러 개발자가 EF 모델을 변경 하 고 동시에 소스 제어에 제출할 때 문제가 발생 하기 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-175">Issues start to arise when you have multiple developers making changes to the EF model and submitting to source control at the same time.</span></span> <span data-ttu-id="7b944-176">사용자가 마지막으로 동기화 한 후 다른 개발자가 원본 제어에 제출한 마이그레이션과 로컬 마이그레이션을 병합 하는 첫 번째 클래스 방법이 없다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-176">What EF lacks is a first class way to merge your local migrations with migrations that another developer has submitted to source control since you last synced.</span></span>

## <a name="an-example-of-a-merge-conflict"></a><span data-ttu-id="7b944-177">병합 충돌의 예</span><span class="sxs-lookup"><span data-stu-id="7b944-177">An example of a merge conflict</span></span>

<span data-ttu-id="7b944-178">먼저 이러한 병합 충돌에 대 한 구체적인 예를 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-178">First let’s look at a concrete example of such a merge conflict.</span></span> <span data-ttu-id="7b944-179">앞에서 살펴본 예제를 계속 진행 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-179">We’ll continue on with the example we looked at earlier.</span></span> <span data-ttu-id="7b944-180">시작 지점으로 이전 섹션의 변경 내용이 원래 개발자에 의해 체크 인 된 것으로 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-180">As a starting point let’s assume the changes from the previous section were checked in by the original developer.</span></span> <span data-ttu-id="7b944-181">코드 베이스를 변경할 때 개발자 두 명의 개발자를 추적 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-181">We’ll track two developers as they make changes to code base.</span></span>

<span data-ttu-id="7b944-182">몇 가지 변경 내용에 대해 EF 모델 및 마이그레이션을 추적 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-182">We’ll track the EF model and the migrations thru a number of changes.</span></span> <span data-ttu-id="7b944-183">다음 그림에 나와 있는 것 처럼 시작 지점의 경우 두 개발자가 소스 제어 리포지토리에 동기화 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-183">For a starting point, both developers have synced to the source control repository, as depicted in the following graphic.</span></span>

![시작점](~/ef6/media/startingpoint.png)

<span data-ttu-id="7b944-185">개발자 \#1 및 developer \#2는 이제 로컬 코드 베이스에서 EF 모델을 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-185">Developer \#1 and developer \#2 now makes some changes to the EF model in their local code base.</span></span> <span data-ttu-id="7b944-186">개발자 \#1은 **등급** 속성을 **블로그에** 추가 하 고, 데이터베이스에 변경 내용을 적용 하는 **addrating** 마이그레이션을 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-186">Developer \#1 adds a **Rating** property to **Blog** – and generates an **AddRating** migration to apply the changes to the database.</span></span> <span data-ttu-id="7b944-187">개발자 \#2는 **블로그** 에 **Readers** 속성을 추가 하 고 해당 하는 **addreaders** 마이그레이션을 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-187">Developer \#2 adds a **Readers** property to **Blog** – and generates the corresponding **AddReaders** migration.</span></span> <span data-ttu-id="7b944-188">두 개발자는 모두 **업데이트 데이터베이스**를 실행 하 여 로컬 데이터베이스에 변경 내용을 적용 한 다음 응용 프로그램 개발을 계속 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-188">Both developers run **Update-Database**, to apply the changes to their local databases, and then continue developing the application.</span></span>

> [!NOTE]
> <span data-ttu-id="7b944-189">마이그레이션에는 타임 스탬프가 접두사로 추가 되기 때문에이 그래픽은 개발자 \#1에서 Addreaders 마이그레이션 후에 개발자 \#2의 AddReaders 마이그레이션이 제공 되었음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-189">Migrations are prefixed with a timestamp, so our graphic represents that the AddReaders migration from Developer \#2 comes after the AddRating migration from Developer \#1.</span></span> <span data-ttu-id="7b944-190">개발자 \#1 또는 \#2에서 마이그레이션을 먼저 생성 했는지 여부에 관계 없이 팀에서 작업 하는 문제 또는 다음 섹션에서 볼 수 있도록 병합 하는 프로세스에 차이가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-190">Whether developer \#1 or \#2 generated the migration first makes no difference to the issues of working in a team, or the process for merging them that we’ll look at in the next section.</span></span>

![로컬 변경](~/ef6/media/localchanges.png)

<span data-ttu-id="7b944-192">개발자 \#1이 변경 내용을 먼저 제출 하는 것과 같은 1 일이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-192">It’s a lucky day for Developer \#1 as they happen to submit their changes first.</span></span> <span data-ttu-id="7b944-193">다른 사용자가 리포지토리를 동기화 한 후 체크 인하지 않았기 때문에 병합을 수행 하지 않고 변경 내용을 전송할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-193">Because no one else has checked in since they synced their repository, they can just submit their changes without performing any merging.</span></span>

![전송](~/ef6/media/submit.png)

<span data-ttu-id="7b944-195">이제 개발자 \#2가 제출 하는 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-195">Now it’s time for Developer \#2 to submit.</span></span> <span data-ttu-id="7b944-196">그렇다면 운이 좋은 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-196">They aren’t so lucky.</span></span> <span data-ttu-id="7b944-197">다른 사용자가 동기화 된 후에 변경 내용을 전송 했기 때문에 변경 내용을 가져와서 병합 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-197">Because someone else has submitted changes since they synced, they will need to pull down the changes and merge.</span></span> <span data-ttu-id="7b944-198">소스 제어 시스템은 매우 간단 하므로 코드 수준에서 변경 내용을 자동으로 병합할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-198">The source control system will likely be able to automatically merge the changes at the code level since they are very simple.</span></span> <span data-ttu-id="7b944-199">다음 그림에서는 동기화 후의 개발자 \#2 로컬 리포지토리의 상태를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-199">The state of Developer \#2’s local repository after syncing is depicted in the following graphic.</span></span> 

![끌어오기](~/ef6/media/pull.png)

<span data-ttu-id="7b944-201">이 단계에서 개발자 \#2는 새 **Addrating** 마이그레이션 (개발자 \#2의 데이터베이스에 적용 되지 않은)을 검색 하 고 적용 하는 **업데이트 데이터베이스** 를 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-201">At this stage Developer \#2 can run **Update-Database** which will detect the new **AddRating** migration (which hasn’t been applied to Developer \#2’s database) and apply it.</span></span> <span data-ttu-id="7b944-202">이제 **등급** 열이 **블로그** 테이블에 추가 되 고 데이터베이스가 모델과 동기화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-202">Now the **Rating** column is added to the **Blogs** table and the database is in sync with the model.</span></span>

<span data-ttu-id="7b944-203">하지만 다음과 같은 몇 가지 문제가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-203">There are a couple of problems though:</span></span>

1.  <span data-ttu-id="7b944-204">**업데이트-데이터베이스** 는 **addrating** 마이그레이션을 적용 하지만 경고를 발생 시킵니다. *보류 중인 변경 내용이 있고 자동 마이그레이션을 사용 하지 않도록 설정 되어 있으므로 현재 모델과 일치 하도록 데이터베이스를 업데이트할 수 없습니다* .</span><span class="sxs-lookup"><span data-stu-id="7b944-204">Although **Update-Database** will apply the **AddRating** migration it will also raise a warning: *Unable to update database to match the current model because there are pending changes and automatic migration is disabled…*</span></span>
    <span data-ttu-id="7b944-205">문제는 마이그레이션이 생성 될 때 모델의 일부가 아니므로 마지막 마이그레이션 (**Addreader** **)에 저장** 된 모델 스냅숏에 **등급** 속성이 누락 되었다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-205">The problem is that the model snapshot stored in the last migration (**AddReader**) is missing the **Rating** property on **Blog** (since it wasn’t part of the model when the migration was generated).</span></span> <span data-ttu-id="7b944-206">Code First는 마지막 마이그레이션의 모델이 현재 모델과 일치 하지 않음을 감지 하 고 경고를 발생 시킵니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-206">Code First detects that the model in the last migration doesn’t match the current model and raises the warning.</span></span>
2.  <span data-ttu-id="7b944-207">응용 프로그램을 실행 하면 " *' BloggingContext ' 컨텍스트를 지 원하는 모델이 데이터베이스를 만든 후에 변경 되었음을 나타내는 InvalidOperationException이 발생 합니다. Code First 마이그레이션를 사용 하 여 데이터베이스를 업데이트 하는 것이 좋습니다. "*</span><span class="sxs-lookup"><span data-stu-id="7b944-207">Running the application would result in an InvalidOperationException stating that “*The model backing the 'BloggingContext' context has changed since the database was created. Consider using Code First Migrations to update the database…”*</span></span>
    <span data-ttu-id="7b944-208">이 문제는 마지막 마이그레이션에 저장 된 모델 스냅숏이 현재 모델과 일치 하지 않는다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-208">Again, the problem is the model snapshot stored in the last migration doesn’t match the current model.</span></span>
3.  <span data-ttu-id="7b944-209">마지막으로, 이제 **추가 마이그레이션을** 실행 하 게 될 예정입니다. 데이터베이스에 적용 되는 변경 내용이 없기 때문에 이제 빈 마이그레이션이 생성 될 것입니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-209">Finally, we would expect running **Add-Migration** now would generate an empty migration (since there are no changes to apply to the database).</span></span> <span data-ttu-id="7b944-210">그러나 마이그레이션은 현재 모델을 마지막 마이그레이션 ( **등급** 속성이 누락 됨)의 경우와 비교 하기 때문에 실제로는 **등급** 열에 추가 하는 또 다른 **addcolumn** 호출을 스 캐 폴드 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-210">But because migrations compares the current model to the one from the last migration (which is missing the **Rating** property) it will actually scaffold another **AddColumn** call to add in the **Rating** column.</span></span> <span data-ttu-id="7b944-211">물론이 마이그레이션은 **업데이트 데이터베이스** 중에는 **등급** 열이 이미 존재 하기 때문에 실패 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-211">Of course, this migration would fail during **Update-Database** because the **Rating** column already exists.</span></span>

## <a name="resolving-the-merge-conflict"></a><span data-ttu-id="7b944-212">병합 충돌 해결</span><span class="sxs-lookup"><span data-stu-id="7b944-212">Resolving the merge conflict</span></span>

<span data-ttu-id="7b944-213">좋은 소식은 병합을 수동으로 처리할 필요가 없다는 것입니다. 마이그레이션이 작동 하는 방식을 이해 하 고 있는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-213">The good news is that it’s not too hard to deal with the merge manually – provided you have an understanding of how migrations works.</span></span> <span data-ttu-id="7b944-214">따라서이 섹션 앞에서 건너뛴 경우 ...</span><span class="sxs-lookup"><span data-stu-id="7b944-214">So if you’ve skipped ahead to this section…</span></span> <span data-ttu-id="7b944-215">죄송 합니다. 뒤로 돌아가서 문서의 나머지 부분을 읽어 보세요.</span><span class="sxs-lookup"><span data-stu-id="7b944-215">sorry, you need to go back and read the rest of the article first!</span></span>

<span data-ttu-id="7b944-216">두 가지 옵션이 있습니다. 가장 쉬운 방법은 올바른 현재 모델을 스냅숏으로 포함 하는 빈 마이그레이션을 생성 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-216">There are two options, the easiest is to generate a blank migration that has the correct current model as a snapshot.</span></span> <span data-ttu-id="7b944-217">두 번째 옵션은 올바른 모델 스냅숏을 갖도록 마지막 마이그레이션의 스냅숏을 업데이트 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-217">The second option is to update the snapshot in the last migration to have the correct model snapshot.</span></span> <span data-ttu-id="7b944-218">두 번째 옵션은 약간 더 어렵고 모든 시나리오에서 사용할 수 없지만 추가 마이그레이션을 추가 하는 작업이 포함 되지 않기 때문에 클리너입니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-218">The second option is a little harder and can’t be used in every scenario, but it’s also cleaner because it doesn’t involve adding an extra migration.</span></span>

### <a name="option-1-add-a-blank-merge-migration"></a><span data-ttu-id="7b944-219">옵션 1: 빈 ' 병합 ' 마이그레이션 추가</span><span class="sxs-lookup"><span data-stu-id="7b944-219">Option 1: Add a blank ‘merge’ migration</span></span>

<span data-ttu-id="7b944-220">이 옵션에서는 최신 마이그레이션에 올바른 모델 스냅숏이 저장 되었는지 확인 하기 위해 빈 마이그레이션만 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-220">In this option we generate a blank migration solely for the purpose of making sure the latest migration has the correct model snapshot stored in it.</span></span>

<span data-ttu-id="7b944-221">이 옵션은 마지막 마이그레이션을 생성 한 사람에 관계 없이 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-221">This option can be used regardless of who generated the last migration.</span></span> <span data-ttu-id="7b944-222">이 예에서는 개발자 \#2가 병합을 처리 하 고 마지막 마이그레이션을 생성 하는 데 참여 했습니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-222">In the example we’ve been following Developer \#2 is taking care of the merge and they happened to generate the last migration.</span></span> <span data-ttu-id="7b944-223">하지만 개발자 \#1에서 마지막 마이그레이션을 생성 한 경우에도 이와 동일한 단계를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-223">But these same steps can be used if Developer \#1 generated the last migration.</span></span> <span data-ttu-id="7b944-224">이러한 단계는 여러 마이그레이션이 관련 된 경우에도 적용 됩니다. 간단 하 게 유지 하기 위해 2를 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-224">The steps also apply if there are multiple migrations involved – we’ve just been looking at two in order to keep it simple.</span></span>

<span data-ttu-id="7b944-225">소스 제어에서 동기화 해야 하는 변경 사항이 있는 경우부터 다음 프로세스를이 방법으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-225">The following process can be used for this approach, starting from the time you realize you have changes that need to be synced from source control.</span></span>

1.  <span data-ttu-id="7b944-226">로컬 코드 베이스의 보류 중인 모든 모델 변경 내용이 마이그레이션에 기록 되었는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-226">Ensure any pending model changes in your local code base have been written to a migration.</span></span> <span data-ttu-id="7b944-227">이 단계를 수행 하면 빈 마이그레이션을 생성할 때 합법적인 변경 사항을 놓치지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-227">This step ensures you don’t miss any legitimate changes when it comes time to generate the blank migration.</span></span>
2.  <span data-ttu-id="7b944-228">소스 제어와 동기화 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-228">Sync with source control.</span></span>
3.  <span data-ttu-id="7b944-229">**업데이트-데이터베이스** 를 실행 하 여 다른 개발자가 체크 인 한 새 마이그레이션을 적용 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-229">Run **Update-Database** to apply any new migrations that other developers have checked in.</span></span>
    <span data-ttu-id="7b944-230">**_참고:_** *업데이트 데이터베이스 명령에서 경고를 얻지 못한 경우 다른 개발자 로부터 새로운 마이그레이션이 수행 되지 않으므로 추가 병합을 수행할 필요가 없습니다.*</span><span class="sxs-lookup"><span data-stu-id="7b944-230">**_Note:_** *if you don’t get any warnings from the Update-Database command then there were no new migrations from other developers and there is no need to perform any further merging.*</span></span>
4.  <span data-ttu-id="7b944-231">**추가 마이그레이션 &lt;를 실행 하 여\_이름&gt; – IgnoreChanges** (예: **IgnoreChanges**)를\_선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-231">Run **Add-Migration &lt;pick\_a\_name&gt; –IgnoreChanges** (for example, **Add-Migration Merge –IgnoreChanges**).</span></span> <span data-ttu-id="7b944-232">이렇게 하면 모든 메타 데이터 (현재 모델의 스냅숏 포함)를 사용 하 여 마이그레이션이 생성 되지만 마지막 마이그레이션의 스냅숏과 현재 모델을 비교할 때 검색 된 모든 변경 내용은 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-232">This generates a migration with all the metadata (including a snapshot of the current model) but will ignore any changes it detects when comparing the current model to the snapshot in the last migrations (meaning you get a blank **Up** and **Down** method).</span></span>
5.  <span data-ttu-id="7b944-233">작업 단위 테스트를 실행 한 후 계속 해 서 개발 하거나 소스 제어에 제출 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-233">Continue developing, or submit to source control (after running your unit tests of course).</span></span>

<span data-ttu-id="7b944-234">이 방법을 사용한 후의 개발자 \#2 로컬 코드 베이스의 상태는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-234">Here is the state of Developer \#2’s local code base after using this approach.</span></span>

![병합 마이그레이션](~/ef6/media/mergemigration.png)

### <a name="option-2-update-the-model-snapshot-in-the-last-migration"></a><span data-ttu-id="7b944-236">옵션 2: 마지막 마이그레이션의 모델 스냅숏 업데이트</span><span class="sxs-lookup"><span data-stu-id="7b944-236">Option 2: Update the model snapshot in the last migration</span></span>

<span data-ttu-id="7b944-237">이 옵션은 옵션 1과 매우 비슷하며 솔루션에 추가 코드 파일을 사용 하려는 사용자를 위해 추가 빈 마이그레이션이 제거 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-237">This option is very similar to option 1 but removes the extra blank migration – because let’s face it, who wants extra code files in their solution.</span></span>

<span data-ttu-id="7b944-238">**이 방법은 최신 마이그레이션이 로컬 코드 베이스에만 존재 하 고 소스 제어에 아직 제출 되지 않은 경우 (예: 병합을 수행 하는 사용자가 마지막 마이그레이션을 생성 한 경우)에만 적합**합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-238">**This approach is only feasible if the latest migration exists only in your local code base and has not yet been submitted to source control (for example, if the last migration was generated by the user doing the merge)**.</span></span> <span data-ttu-id="7b944-239">다른 개발자가 이미 개발 데이터베이스에 적용 했을 수 있거나 프로덕션 데이터베이스에 적용 되지 않는 마이그레이션의 메타 데이터를 편집 하는 경우 예기치 않은 부작용이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-239">Editing the metadata of migrations that other developers may have already applied to their development database – or even worse applied to a production database – can result in unexpected side effects.</span></span> <span data-ttu-id="7b944-240">프로세스 중에 로컬 데이터베이스의 마지막 마이그레이션을 롤백하고 업데이트 된 메타 데이터로 다시 적용 하겠습니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-240">During the process we’re going to roll back the last migration in our local database and re-apply it with updated metadata.</span></span>

<span data-ttu-id="7b944-241">마지막 마이그레이션은 로컬 코드 베이스에만 있어야 하지만이를 진행 하는 마이그레이션의 수 또는 순서에는 제한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-241">While the last migration needs to just be in the local code base there are no restrictions to the number or order of migrations that proceed it.</span></span> <span data-ttu-id="7b944-242">여러 다른 개발자의 마이그레이션이 여러 개 있을 수 있으며, 동일한 단계가 적용 됩니다. 간단 하 게 유지 하기 위해 2를 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-242">There can be multiple migrations from multiple different developers and the same steps apply– we’ve just been looking at two in order to keep it simple.</span></span>

<span data-ttu-id="7b944-243">소스 제어에서 동기화 해야 하는 변경 사항이 있는 경우부터 다음 프로세스를이 방법으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-243">The following process can be used for this approach, starting from the time you realize you have changes that need to be synced from source control.</span></span>

1.  <span data-ttu-id="7b944-244">로컬 코드 베이스의 보류 중인 모든 모델 변경 내용이 마이그레이션에 기록 되었는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-244">Ensure any pending model changes in your local code base have been written to a migration.</span></span> <span data-ttu-id="7b944-245">이 단계를 수행 하면 빈 마이그레이션을 생성할 때 합법적인 변경 사항을 놓치지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-245">This step ensures you don’t miss any legitimate changes when it comes time to generate the blank migration.</span></span>
2.  <span data-ttu-id="7b944-246">원본 제어와 동기화 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-246">Sync with the source control.</span></span>
3.  <span data-ttu-id="7b944-247">**업데이트-데이터베이스** 를 실행 하 여 다른 개발자가 체크 인 한 새 마이그레이션을 적용 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-247">Run **Update-Database** to apply any new migrations that other developers have checked in.</span></span>
    <span data-ttu-id="7b944-248">**_참고:_** *업데이트 데이터베이스 명령에서 경고를 얻지 못한 경우 다른 개발자 로부터 새로운 마이그레이션이 수행 되지 않으므로 추가 병합을 수행할 필요가 없습니다.*</span><span class="sxs-lookup"><span data-stu-id="7b944-248">**_Note:_** *if you don’t get any warnings from the Update-Database command then there were no new migrations from other developers and there is no need to perform any further merging.*</span></span>
4.  <span data-ttu-id="7b944-249">**업데이트-데이터베이스-targetmigration &lt;두 번째\_마지막\_마이그레이션&gt;** 를 실행 합니다. 예를 들어 다음 예제에서는 **업데이트-데이터베이스-Targetmigration addrating**입니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-249">Run **Update-Database –TargetMigration &lt;second\_last\_migration&gt;** (in the example we’ve been following this would be **Update-Database –TargetMigration AddRating**).</span></span> <span data-ttu-id="7b944-250">이렇게 하면 데이터베이스에서 마지막으로 마지막으로 마이그레이션한 후에 데이터베이스의 마지막 마이그레이션 상태가 다시 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-250">This roles the database back to the state of the second last migration – effectively ‘un-applying’ the last migration from the database.</span></span>
    <span data-ttu-id="7b944-251">**_참고:_** *메타 데이터는 데이터베이스의 \_\_MigrationsHistoryTable에도 저장 되므로 마이그레이션의 메타 데이터를 안전 하 게 편집 하려면이 단계가 필요 합니다. 이것은 마지막 마이그레이션이 로컬 코드 베이스에만 있는 경우에만이 옵션을 사용 해야 하는 이유입니다. 다른 데이터베이스에서 마지막 마이그레이션을 적용 한 경우 해당 데이터베이스를 롤백하고 마지막 마이그레이션을 다시 적용 하 여 메타 데이터를 업데이트 해야 합니다.*</span><span class="sxs-lookup"><span data-stu-id="7b944-251">**_Note:_** *This step is required to make it safe to edit the metadata of the migration since the metadata is also stored in the \_\_MigrationsHistoryTable of the database. This is why you should only use this option if the last migration is only in your local code base. If other databases had the last migration applied you would also have to roll them back and re-apply the last migration to update the metadata.*</span></span> 
5.  <span data-ttu-id="7b944-252">\_**마지막\_마이그레이션\_의\_타임 스탬프&gt;를 비롯 한 전체\_이름\_&lt;전체 마이그레이션 추가** 를 실행 합니다 (이 예제에서는 다음에 나오는 예제에서는 **추가-마이그레이션 201311062215252\_addreaders**와 같은 것입니다).</span><span class="sxs-lookup"><span data-stu-id="7b944-252">Run **Add-Migration &lt;full\_name\_including\_timestamp\_of\_last\_migration**&gt; (in the example we’ve been following this would be something like **Add-Migration 201311062215252\_AddReaders**).</span></span>
    <span data-ttu-id="7b944-253">**_참고:_** *새 마이그레이션을 스 캐 폴딩 하지 않고 기존 마이그레이션을 편집 하려고 한다는 것을 알 수 있도록 타임 스탬프를 포함 해야* 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-253">**_Note:_** *You need to include the timestamp so that migrations knows you want to edit the existing migration rather than scaffolding a new one.*</span></span>
    <span data-ttu-id="7b944-254">그러면 현재 모델과 일치 하도록 마지막 마이그레이션의 메타 데이터가 업데이트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-254">This will update the metadata for the last migration to match the current model.</span></span> <span data-ttu-id="7b944-255">명령이 완료 되 면 다음과 같은 경고가 표시 됩니다 .이는 정확히 원하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-255">You’ll get the following warning when the command completes, but that’s exactly what you want.</span></span> <span data-ttu-id="7b944-256">" *' 201311062215252\_AddReaders ' 마이그레이션의 디자이너 코드만 다시 스 캐 폴드 되었습니다. 전체 마이그레이션을 다시 스 캐 폴드-Force 매개 변수를 사용 합니다.*</span><span class="sxs-lookup"><span data-stu-id="7b944-256">“*Only the Designer Code for migration '201311062215252\_AddReaders' was re-scaffolded. To re-scaffold the entire migration, use the -Force parameter.”*</span></span>
6.  <span data-ttu-id="7b944-257">업데이트 **-데이터베이스** 를 실행 하 여 업데이트 된 메타 데이터로 최신 마이그레이션을 다시 적용 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-257">Run **Update-Database** to re-apply the latest migration with the updated metadata.</span></span>
7.  <span data-ttu-id="7b944-258">작업 단위 테스트를 실행 한 후 계속 해 서 개발 하거나 소스 제어에 제출 합니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-258">Continue developing, or submit to source control (after running your unit tests of course).</span></span>

<span data-ttu-id="7b944-259">이 방법을 사용한 후의 개발자 \#2 로컬 코드 베이스의 상태는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-259">Here is the state of Developer \#2’s local code base after using this approach.</span></span>

![업데이트 된 메타 데이터](~/ef6/media/updatedmetadata.png)

## <a name="summary"></a><span data-ttu-id="7b944-261">요약</span><span class="sxs-lookup"><span data-stu-id="7b944-261">Summary</span></span>

<span data-ttu-id="7b944-262">팀 환경에서 Code First 마이그레이션를 사용 하는 경우 몇 가지 과제가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-262">There are some challenges when using Code First Migrations in a team environment.</span></span> <span data-ttu-id="7b944-263">그러나 마이그레이션의 작동 원리와 병합 충돌을 해결 하는 몇 가지 간단한 방법에 대 한 기본적인 이해를 통해 이러한 문제를 쉽게 해결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-263">However, a basic understanding of how migrations works and some simple approaches for resolving merge conflicts make it easy to overcome these challenges.</span></span>

<span data-ttu-id="7b944-264">기본 문제는 최신 마이그레이션에 저장 된 잘못 된 메타 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-264">The fundamental issue is incorrect metadata stored in the latest migration.</span></span> <span data-ttu-id="7b944-265">이로 인해 Code First는 현재 모델 및 데이터베이스 스키마가 일치 하지 않음을 감지 하 고 다음 마이그레이션의 잘못 된 코드를 스 캐 폴드 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-265">This causes Code First to incorrectly detect that the current model and database schema don’t match and to scaffold incorrect code in the next migration.</span></span> <span data-ttu-id="7b944-266">이 상황은 올바른 모델을 사용 하 여 빈 마이그레이션을 생성 하거나 최신 마이그레이션의 메타 데이터를 업데이트 하 여 해결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7b944-266">This situation can be overcome by generating a blank migration with the correct model, or updating the metadata in the latest migration.</span></span>
