---
title: 기존 데이터베이스로 Code First 마이그레이션-EF6
author: divega
ms.date: 10/23/2016
ms.assetid: f0cc4f93-67dd-4664-9753-0a9f913814db
ms.openlocfilehash: eb7948eafb1322cabcf69b47bd5411f762fe8498
ms.sourcegitcommit: 708b18520321c587b2046ad2ea9fa7c48aeebfe5
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/09/2019
ms.locfileid: "72182578"
---
# <a name="code-first-migrations-with-an-existing-database"></a>기존 데이터베이스를 사용 하 여 Code First 마이그레이션
> [!NOTE]
> **Ef 4.3** 이상-이 페이지에서 설명 하는 기능, api 등은 Entity Framework 4.1에서 도입 되었습니다. 이전 버전을 사용하는 경우 이 정보의 일부 또는 전체가 적용되지 않습니다.

이 문서에서는 Entity Framework에 의해 생성 되지 않은 기존 데이터베이스와 Code First 마이그레이션를 사용 하는 방법을 설명 합니다.

> [!NOTE]
> 이 문서에서는 기본 시나리오에서 Code First 마이그레이션를 사용 하는 방법을 알고 있다고 가정 합니다. 그렇지 않으면 계속 하기 전에 [Code First 마이그레이션](~/ef6/modeling/code-first/migrations/index.md) 읽어야 합니다.

## <a name="screencasts"></a>스크린 캐스트

이 문서를 읽는 것 보다 동영상 가이드을 시청 하는 경우 다음 두 비디오는이 문서와 동일한 콘텐츠를 포함 합니다.

### <a name="video-one-migrations---under-the-hood"></a>비디오 1: "마이그레이션-내부"

[이 동영상 가이드](https://channel9.msdn.com/blogs/ef/migrations-under-the-hood) 는 마이그레이션이 모델 변경 내용을 검색 하는 모델에 대 한 정보를 추적 하 고 사용 하는 방법을 설명 합니다.

### <a name="video-two-migrations---existing-databases"></a>비디오 2: "마이그레이션-기존 데이터베이스"

이전 비디오에서 개념을 기반으로 구축 된 [이 동영상 가이드](https://channel9.msdn.com/blogs/ef/migrations-existing-databases) 는 기존 데이터베이스에서 마이그레이션을 사용 하도록 설정 하 고 사용 하는 방법을 다룹니다.

## <a name="step-1-create-a-model"></a>1 단계: 모델 만들기

첫 번째 단계는 기존 데이터베이스를 대상으로 하는 Code First 모델을 만드는 것입니다. [기존 데이터베이스에 Code First](~/ef6/modeling/code-first/workflows/existing-database.md) 항목은이 작업을 수행 하는 방법에 대 한 자세한 지침을 제공 합니다.

>[!NOTE]
> 데이터베이스 스키마를 변경 해야 하는 모델을 변경 하기 전에이 항목의 나머지 단계를 수행 하는 것이 중요 합니다. 다음 단계를 수행 하려면 모델을 데이터베이스 스키마와 동기화 해야 합니다.

## <a name="step-2-enable-migrations"></a>2 단계: 마이그레이션 사용

다음 단계는 마이그레이션을 사용 하도록 설정 하는 것입니다. 패키지 관리자 콘솔에서 **마이그레이션 사용** 명령을 실행 하 여이 작업을 수행할 수 있습니다.

이 명령은 솔루션에서 마이그레이션 이라는 폴더를 만들고 구성 이라는 단일 클래스를 포함 합니다. 구성 클래스에서는 응용 프로그램에 대 한 마이그레이션을 구성할 수 있으며,이에 대 한 자세한 내용은 [Code First 마이그레이션](~/ef6/modeling/code-first/migrations/index.md) 항목에서 확인할 수 있습니다.

## <a name="step-3-add-an-initial-migration"></a>3 단계: 초기 마이그레이션 추가

마이그레이션을 만들고 로컬 데이터베이스에 적용 한 후에는 이러한 변경 내용을 다른 데이터베이스에 적용할 수도 있습니다. 예를 들어 로컬 데이터베이스는 테스트 데이터베이스이 고 궁극적으로 프로덕션 데이터베이스 및/또는 다른 개발자 테스트 데이터베이스에 변경 내용을 적용 하려는 경우가 있습니다. 이 단계에서는 두 가지 옵션을 사용할 수 있으며, 선택 해야 하는 옵션은 다른 데이터베이스의 스키마가 비어 있거나 현재 로컬 데이터베이스의 스키마와 일치 하는지 여부에 따라 달라 집니다.

-   **옵션 1: 기존 스키마를 시작 지점으로 사용 합니다.** 나중에 마이그레이션에 적용 되는 다른 데이터베이스에 현재 로컬 데이터베이스와 동일한 스키마가 있는 경우이 방법을 사용 해야 합니다. 예를 들어 로컬 테스트 데이터베이스가 현재 프로덕션 데이터베이스의 v1과 일치 하 고 나중에 이러한 마이그레이션을 적용 하 여 프로덕션 데이터베이스를 v 2로 업데이트 하는 경우이를 사용할 수 있습니다.
-   **옵션 2: 빈 데이터베이스를 시작 지점으로 사용 합니다.** 나중에 마이그레이션이 적용 되는 다른 데이터베이스가 비어 있거나 아직 존재 하지 않는 경우이 방법을 사용 해야 합니다. 예를 들어, 테스트 데이터베이스를 사용 하 여 응용 프로그램 개발을 시작 했지만 마이그레이션을 사용 하지 않고 나중에 프로덕션 데이터베이스를 처음부터 만들려는 경우이를 사용할 수 있습니다.

### <a name="option-one-use-existing-schema-as-a-starting-point"></a>옵션 1: 기존 스키마를 시작 지점으로 사용 합니다.

Code First 마이그레이션은 최신 마이그레이션에 저장 된 모델의 스냅숏을 사용 하 여 모델에 대 한 변경 내용을 검색 합니다 .이에 대 한 자세한 내용은 [팀 환경 Code First 마이그레이션](~/ef6/modeling/code-first/migrations/teams.md)에서 확인할 수 있습니다. 데이터베이스에 현재 모델의 스키마가 이미 있다고 가정 하기 때문에 현재 모델을 스냅숏으로 포함 하는 빈 (op 없음) 마이그레이션을 생성 합니다.

1.  패키지 관리자 콘솔에서 **추가-마이그레이션 InitialCreate – IgnoreChanges** 명령을 실행 합니다. 그러면 현재 모델을 스냅숏으로 빈 마이그레이션이 생성 됩니다.
2.  패키지 관리자 콘솔에서 **업데이트 데이터베이스** 명령을 실행 합니다. 이렇게 하면 데이터베이스에 InitialCreate migration이 적용 됩니다. 실제 마이그레이션에는 변경 내용이 포함 되어 있지 않으므로이 마이그레이션이 이미 적용 되었음을 나타내는 행을 \_\_MigrationsHistory 테이블에 추가 하기만 하면 됩니다.

### <a name="option-two-use-empty-database-as-a-starting-point"></a>옵션 2: 빈 데이터베이스를 시작 지점으로 사용

이 시나리오에서는 로컬 데이터베이스에 이미 있는 테이블을 포함 하 여 전체 데이터베이스를 처음부터 새로 만들 수 있는 마이그레이션이 필요 합니다. 기존 스키마를 만드는 논리를 포함 하는 InitialCreate migration을 생성할 예정입니다. 그런 다음이 마이그레이션과 이미 적용 된 것 처럼 기존 데이터베이스를 만듭니다.

1.  패키지 관리자 콘솔에서 **추가 마이그레이션 InitialCreate** 명령을 실행 합니다. 이렇게 하면 기존 스키마를 만드는 마이그레이션이 생성 됩니다.
2.  새로 만든 마이그레이션의 Up 메서드에서 모든 코드를 주석으로 처리 합니다. 이렇게 하면 이미 존재 하는 모든 테이블 등을 다시 만들려고 하지 않고 로컬 데이터베이스에 대 한 마이그레이션을 ' 적용 ' 할 수 있습니다.
3.  패키지 관리자 콘솔에서 **업데이트 데이터베이스** 명령을 실행 합니다. 이렇게 하면 데이터베이스에 InitialCreate migration이 적용 됩니다. 실제 마이그레이션에는 변경 내용이 포함 되어 있지 않기 때문에 (일시적으로 주석 처리 되기 때문에)이 마이그레이션이 이미 적용 되었음을 나타내는 \_\_MigrationsHistory 테이블에 행이 추가 됩니다.
4.  Up 메서드에서 코드의 주석을 해제 합니다. 즉,이 마이그레이션이 이후 데이터베이스에 적용 되는 경우 로컬 데이터베이스에 이미 있던 스키마는 마이그레이션에 의해 생성 됩니다.

## <a name="things-to-be-aware-of"></a>알아두어야 할 사항

기존 데이터베이스에 대해 마이그레이션을 사용할 때 알아야 할 몇 가지 사항이 있습니다.

### <a name="defaultcalculated-names-may-not-match-existing-schema"></a>기본/계산 된 이름이 기존 스키마와 일치 하지 않을 수 있습니다.

마이그레이션은 마이그레이션을 스 캐 폴드 때 열과 테이블의 이름을 명시적으로 지정 합니다. 그러나 마이그레이션은 마이그레이션을 적용할 때의 기본 이름을 계산 하는 다른 데이터베이스 개체가 있습니다. 여기에는 인덱스와 foreign key 제약 조건이 포함 됩니다. 기존 스키마를 대상으로 지정 하는 경우 이러한 계산 된 이름이 데이터베이스에 실제로 존재 하는 이름과 일치 하지 않을 수 있습니다.

다음은이에 대해 알고 있어야 하는 경우의 몇 가지 예입니다.

**' 옵션 1: 기존 스키마를 시작 지점으로 사용 '을 사용 하는 경우 3 단계:**

-   나중에 모델을 변경할 때 이름이 다른 데이터베이스 개체 중 하나를 변경 하거나 삭제 해야 하는 경우에는 스 캐 폴드 마이그레이션을 수정 하 여 올바른 이름을 지정 해야 합니다. 마이그레이션 Api에는이 작업을 수행할 수 있는 선택적 이름 매개 변수가 있습니다.
    예를 들어 기존 스키마에 인덱스 이름이 IndexFk\_BlogId 인 BlogId 외래 키 열이 있는 Post 테이블이 있을 수 있습니다. 그러나 기본적으로 마이그레이션은이 인덱스의 이름을 IX\_BlogId로 지정 합니다. 이 인덱스를 삭제 하는 모델을 변경 하는 경우 스 캐 폴드 DropIndex 호출을 수정 하 여 IndexFk\_BlogId name을 지정 해야 합니다.

**' 옵션 2: 빈 데이터베이스를 시작 지점으로 사용 '을 사용 하는 경우 3 단계:**

-   마이그레이션이 잘못 된 이름을 사용 하 여 인덱스와 foreign key 제약 조건을 삭제 하려고 하기 때문에 로컬 데이터베이스에 대해 초기 마이그레이션 (즉, 빈 데이터베이스로 되돌리기)의 다운 메서드를 실행 하려고 하면 실패할 수 있습니다. 이는 초기 마이그레이션의 Up 메서드를 사용 하 여 다른 데이터베이스를 처음부터 만들기 때문에 로컬 데이터베이스에만 영향을 줍니다.
    기존 로컬 데이터베이스를 빈 상태로 다운 그레이드 하려면 데이터베이스를 삭제 하거나 모든 테이블을 삭제 하 여이 작업을 수동으로 수행 하는 것이 가장 쉽습니다. 이 초기 다운 그레이드 후에는 모든 데이터베이스 개체가 기본 이름으로 다시 생성 되므로이 문제는 다시 표시 되지 않습니다.
-   나중에 모델을 변경할 때 이름이 다른 데이터베이스 개체 중 하나를 변경 하거나 삭제 해야 하는 경우에는 이름이 기본값과 일치 하지 않기 때문에 기존 로컬 데이터베이스에 대해이 작업을 수행할 수 없습니다. 그러나 마이그레이션에 의해 선택 된 기본 이름을 사용 하기 때문에 ' 처음부터 새로 만든 ' 데이터베이스에 대해 작동 합니다.
    이러한 변경 내용을 로컬 기존 데이터베이스에서 수동으로 변경 하거나, 마이그레이션을 통해 데이터베이스를 처음부터 다시 만드는 것을 고려할 수 있습니다.
-   초기 마이그레이션을 사용 하 여 만든 데이터베이스는 인덱스 및 foreign key 제약 조건에 대해 계산 된 기본 이름을 사용 하기 때문에 로컬 데이터베이스와 약간 다를 수 있습니다. 마이그레이션은 기본적으로 외래 키 열에 인덱스를 만들기 때문에 추가 인덱스가 생성 될 수도 있습니다. 원래 로컬 데이터베이스에 있는 경우가 아닐 수 있습니다.

### <a name="not-all-database-objects-are-represented-in-the-model"></a>모든 데이터베이스 개체가 모델에 표시 되는 것은 아닙니다.

모델에 포함 되지 않은 데이터베이스 개체는 마이그레이션에 의해 처리 되지 않습니다. 여기에는 뷰, 저장 프로시저, 사용 권한, 모델에 포함 되지 않은 테이블, 추가 인덱스 등이 포함 될 수 있습니다.

다음은이에 대해 알고 있어야 하는 경우의 몇 가지 예입니다.

-   ' 3 단계 '에서 선택한 옵션에 관계 없이 나중에 모델을 변경할 때 이러한 추가 개체를 변경 하거나 삭제 해야 하는 경우 마이그레이션은 이러한 변경을 수행 하는 것을 알 수 없습니다. 예를 들어 추가 인덱스가 있는 열을 삭제 하는 경우 마이그레이션은 인덱스를 삭제 하는 것을 알 수 없습니다. 스 캐 폴드 마이그레이션에 수동으로 추가 해야 합니다.
-   ' 옵션 2: 빈 데이터베이스를 시작 지점으로 사용 '을 사용한 경우 초기 마이그레이션의 Up 메서드에서 이러한 추가 개체를 만들지 않습니다.
    원하는 경우 이러한 추가 개체를 처리 하도록 위쪽 및 아래쪽 메서드를 수정할 수 있습니다. 뷰 등의 마이그레이션 API에서 기본적으로 지원 되지 않는 개체의 경우 [sql](https://msdn.microsoft.com/library/system.data.entity.migrations.dbmigration.sql.aspx) 메서드를 사용 하 여 원시 sql을 실행 하 고 해당 개체를 만들거나 삭제할 수 있습니다.
