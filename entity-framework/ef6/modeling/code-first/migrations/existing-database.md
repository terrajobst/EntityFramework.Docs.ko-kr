---
title: 기존 데이터베이스-EF6 사용 하 여 code First 마이그레이션
author: divega
ms.date: 2016-10-23
ms.assetid: f0cc4f93-67dd-4664-9753-0a9f913814db
ms.openlocfilehash: 06aabf3f57ca451f4d9cba469f6de40fd9aa8f23
ms.sourcegitcommit: dadee5905ada9ecdbae28363a682950383ce3e10
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/27/2018
ms.locfileid: "42998199"
---
# <a name="code-first-migrations-with-an-existing-database"></a><span data-ttu-id="b4509-102">기존 데이터베이스를 사용 하 여 code First 마이그레이션</span><span class="sxs-lookup"><span data-stu-id="b4509-102">Code First Migrations with an existing database</span></span>
> [!NOTE]
> <span data-ttu-id="b4509-103">**EF4.3 이상만** -Api 기능 등이이 페이지에 설명 된 Entity Framework 4.1에서 도입 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-103">**EF4.3 Onwards Only** - The features, APIs, etc. discussed in this page were introduced in Entity Framework 4.1.</span></span> <span data-ttu-id="b4509-104">이전 버전을 사용하는 경우 이 정보의 일부 또는 전체가 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-104">If you are using an earlier version, some or all of the information does not apply.</span></span>

<span data-ttu-id="b4509-105">이 문서에서는 Code First 마이그레이션을 사용 하 여 Entity Framework에서 만들어지지 않았으면 하는 기존 데이터베이스를 사용 하 여 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-105">This article covers using Code First Migrations with an existing database, one that wasn’t created by Entity Framework.</span></span>

> [!NOTE]
> <span data-ttu-id="b4509-106">이 문서에서는 기본 시나리오에서 Code First 마이그레이션을 사용 하는 방법을 알고 있다고 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-106">This article assumes you know how to use Code First Migrations in basic scenarios.</span></span> <span data-ttu-id="b4509-107">이렇게 하지 않으면 경우 읽기 해야 [Code First 마이그레이션을](~/ef6/modeling/code-first/migrations/index.md) 계속 하기 전에 합니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-107">If you don’t, then you’ll need to read [Code First Migrations](~/ef6/modeling/code-first/migrations/index.md) before continuing.</span></span>

## <a name="screencasts"></a><span data-ttu-id="b4509-108">스크린 캐스트</span><span class="sxs-lookup"><span data-stu-id="b4509-108">Screencasts</span></span>

<span data-ttu-id="b4509-109">이 문서 보다 동영상을 가이드를 보려면 대신는 경우 다음 두 동영상이이 문서와 동일한 콘텐츠를 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-109">If you'd rather watch a screencast than read this article, the following two videos cover the same content as this article.</span></span>

### <a name="video-one-migrations---under-the-hood"></a><span data-ttu-id="b4509-110">비디오 1: "마이그레이션-내부 살펴보기"</span><span class="sxs-lookup"><span data-stu-id="b4509-110">Video One: "Migrations - Under the Hood"</span></span>

<span data-ttu-id="b4509-111">[이 스크린 캐스트](http://channel9.msdn.com/blogs/ef/migrations-under-the-hood) 마이그레이션을 추적 하는 방법을 설명 하 고 모델에 대 한 정보를 사용 하 여 모델 변경 내용을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-111">[This screencast](http://channel9.msdn.com/blogs/ef/migrations-under-the-hood) covers how migrations tracks and uses information about the model to detect model changes.</span></span>

### <a name="video-two-migrations---existing-databases"></a><span data-ttu-id="b4509-112">비디오 2: "마이그레이션-기존 데이터베이스"</span><span class="sxs-lookup"><span data-stu-id="b4509-112">Video Two: "Migrations - Existing Databases"</span></span>

<span data-ttu-id="b4509-113">이전 비디오에서 개념을 토대로 [이 스크린 캐스트](http://channel9.msdn.com/blogs/ef/migrations-existing-databases) 활성화 하 고 기존 데이터베이스를 사용 하 여 마이그레이션을 사용 하는 방법을 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-113">Building on the concepts from the previous video, [this screencast](http://channel9.msdn.com/blogs/ef/migrations-existing-databases) covers how to enable and use migrations with an existing database.</span></span>

## <a name="step-1-create-a-model"></a><span data-ttu-id="b4509-114">1 단계: 모델 만들기</span><span class="sxs-lookup"><span data-stu-id="b4509-114">Step 1: Create a model</span></span>

<span data-ttu-id="b4509-115">먼저 기존 데이터베이스를 대상으로 하는 Code First 모델을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-115">Your first step will be to create a Code First model that targets your existing database.</span></span> <span data-ttu-id="b4509-116">합니다 [기존 데이터베이스에 Code First](~/ef6/modeling/code-first/workflows/existing-database.md) 항목에서는이 작업을 수행 하는 방법에 자세한 지침을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-116">The [Code First to an Existing Database](~/ef6/modeling/code-first/workflows/existing-database.md) topic provides detailed guidance on how to do this.</span></span>

>[!NOTE]
> <span data-ttu-id="b4509-117">데이터베이스 스키마를 변경 해야 하는 모델을 변경 하기 전에이 항목의 단계를 따릅니다 두는 것이 반드시 합니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-117">It is important to follow the rest of the steps in this topic before making any changes to your model that would require changes to the database schema.</span></span> <span data-ttu-id="b4509-118">다음 단계는 필요 동기화 되도록 모델 데이터베이스 스키마를 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-118">The following steps require the model to be in-sync with the database schema.</span></span>

## <a name="step-2-enable-migrations"></a><span data-ttu-id="b4509-119">2 단계: 마이그레이션 사용</span><span class="sxs-lookup"><span data-stu-id="b4509-119">Step 2: Enable Migrations</span></span>

<span data-ttu-id="b4509-120">마이그레이션을 사용 하도록 설정 하려면 다음 단계가입니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-120">The next step is to enable migrations.</span></span> <span data-ttu-id="b4509-121">실행 하 여 이렇게 합니다 **Enable-migrations** 패키지 관리자 콘솔에서 명령을 합니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-121">You can do this by running the **Enable-Migrations** command in Package Manager Console.</span></span>

<span data-ttu-id="b4509-122">이 명령은 마이그레이션을 호출 하 여 솔루션에서 폴더를 만들고 구성 호출 내 단일 클래스에 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-122">This command will create a folder in your solution called Migrations, and put a single class inside it called Configuration.</span></span> <span data-ttu-id="b4509-123">구성 클래스를 구성 하는 마이그레이션 응용 프로그램에 대 한에 대 한 자세한 내용을 확인할 수는 [Code First 마이그레이션을](~/ef6/modeling/code-first/migrations/index.md) 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-123">The Configuration class is where you configure migrations for your application, you can find out more about it in the [Code First Migrations](~/ef6/modeling/code-first/migrations/index.md) topic.</span></span>

## <a name="step-3-add-an-initial-migration"></a><span data-ttu-id="b4509-124">3 단계: 초기 마이그레이션 추가</span><span class="sxs-lookup"><span data-stu-id="b4509-124">Step 3: Add an initial migration</span></span>

<span data-ttu-id="b4509-125">마이그레이션을 만든 후에 적용 되 면 다른 데이터베이스에 적용 하려면 로컬 데이터베이스 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-125">Once migrations have been created and applied to the local database you may also want to apply these changes to other databases.</span></span> <span data-ttu-id="b4509-126">예를 들어, 로컬 데이터베이스 테스트 데이터베이스 및도 프로덕션 데이터베이스에 변경 내용을 적용 하려는 궁극적으로 및/또는 다른 개발자가 데이터베이스를 테스트 합니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-126">For example, your local database may be a test database and you may ultimately want to also apply the changes to a production database and/or other developers test databases.</span></span> <span data-ttu-id="b4509-127">이 단계는 방법은 두 가지가 및 다른 데이터베이스의 스키마가 비어 있거나 현재 로컬 데이터베이스의 스키마와 일치 여부를 선택 해야 하는 것에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-127">There are two options for this step and the one you should pick depends whether or not the schema of any other databases is empty or currently matches the schema of the local database.</span></span>

-   <span data-ttu-id="b4509-128">**옵션 1: 시작 지점으로 기존 스키마를 사용 합니다.**</span><span class="sxs-lookup"><span data-stu-id="b4509-128">**Option One: Use existing schema as starting point.**</span></span> <span data-ttu-id="b4509-129">로컬 데이터베이스가 현재 되었으므로 나중에 마이그레이션에 적용 됩니다는 다른 데이터베이스에서 동일한 스키마를 해야 하는 경우이 방법을 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-129">You should use this approach when other databases that migrations will be applied to in the future will have the same schema as your local database currently has.</span></span> <span data-ttu-id="b4509-130">예를 들어, 로컬 테스트 데이터베이스에는 현재 프로덕션 데이터베이스의 v1 일치 하 고 이러한 마이그레이션을 v2로 프로덕션 데이터베이스를 업데이트 하려면 나중에 적용할 경우이 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-130">For example, you might use this if your local test database currently matches v1 of your production database and you will later apply these migrations to update your production database to v2.</span></span>
-   <span data-ttu-id="b4509-131">**옵션 2: 시작 지점으로 빈 데이터베이스를 사용 합니다.**</span><span class="sxs-lookup"><span data-stu-id="b4509-131">**Option Two: Use empty database as starting point.**</span></span> <span data-ttu-id="b4509-132">비어 있는 (또는 아직 존재 하지 않는) 나중에 마이그레이션에 적용 됩니다는 다른 데이터베이스가이 방법을 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-132">You should use this approach when other databases that migrations will be applied to in the future are empty (or do not exist yet).</span></span> <span data-ttu-id="b4509-133">예를 들어 테스트 데이터베이스를 사용 하 여 응용 프로그램 개발을 시작 해도 마이그레이션을 하를 사용 하지 않고 나중에 할부터 프로덕션 데이터베이스를 만드는 경우이 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-133">For example, you might use this if you started developing your application using a test database but without using migrations and you will later want to create a production database from scratch.</span></span>

### <a name="option-one-use-existing-schema-as-a-starting-point"></a><span data-ttu-id="b4509-134">옵션 1: 기존 스키마를 사용 하 여 시작 지점으로</span><span class="sxs-lookup"><span data-stu-id="b4509-134">Option One: Use existing schema as a starting point</span></span>

<span data-ttu-id="b4509-135">Code First 마이그레이션을 가장 최근 마이그레이션에 저장 된 모델의 스냅숏을 사용 하 여 모델 변경 내용을 검색 (이에 대 한 자세한 정보를 찾을 수 있습니다 [팀 환경에서 Code First 마이그레이션을](~/ef6/modeling/code-first/migrations/teams.md)).</span><span class="sxs-lookup"><span data-stu-id="b4509-135">Code First Migrations uses a snapshot of the model stored in the most recent migration to detect changes to the model (you can find detailed information about this in [Code First Migrations in Team Environments](~/ef6/modeling/code-first/migrations/teams.md)).</span></span> <span data-ttu-id="b4509-136">데이터베이스에 이미 현재 모델의 스키마는 가정 것 이므로 스냅숏으로 현재 모델이 비어 있는 (아무) 마이그레이션을 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-136">Since we are going to assume that databases already have the schema of the current model, we will generate an empty (no-op) migration that has the current model as a snapshot.</span></span>

1.  <span data-ttu-id="b4509-137">실행 합니다 **Add-migration InitialCreate – IgnoreChanges** 패키지 관리자 콘솔에서 명령을 합니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-137">Run the **Add-Migration InitialCreate –IgnoreChanges** command in Package Manager Console.</span></span> <span data-ttu-id="b4509-138">이 빈 마이그레이션 스냅숏으로 현재 모델을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-138">This creates an empty migration with the current model as a snapshot.</span></span>
2.  <span data-ttu-id="b4509-139">실행 합니다 **Update-database** 패키지 관리자 콘솔에서 명령을 합니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-139">Run the **Update-Database** command in Package Manager Console.</span></span> <span data-ttu-id="b4509-140">InitialCreate 마이그레이션을 데이터베이스에 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-140">This will apply the InitialCreate migration to the database.</span></span> <span data-ttu-id="b4509-141">행을 간단히 추가 실제 마이그레이션을 내용이 들어 있으므로 합니다 \_ \_MigrationsHistory 테이블 나타내는이 마이그레이션이 이미 적용 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-141">Since the actual migration doesn’t contain any changes, it will simply add a row to the \_\_MigrationsHistory table indicating that this migration has already been applied.</span></span>

### <a name="option-two-use-empty-database-as-a-starting-point"></a><span data-ttu-id="b4509-142">옵션 2: 빈 데이터베이스를 사용 하 여 시작 지점으로</span><span class="sxs-lookup"><span data-stu-id="b4509-142">Option Two: Use empty database as a starting point</span></span>

<span data-ttu-id="b4509-143">이 시나리오에서는 로컬 데이터베이스에 존재 하는 테이블을 포함 하 여부터 전체 데이터베이스를 만들 수로 마이그레이션이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-143">In this scenario we need Migrations to be able to create the entire database from scratch – including the tables that are already present in our local database.</span></span> <span data-ttu-id="b4509-144">기존 스키마를 만들기 위한 논리를 포함 하는 InitialCreate 마이그레이션을 생성 하겠습니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-144">We’re going to generate an InitialCreate migration that includes logic to create the existing schema.</span></span> <span data-ttu-id="b4509-145">그런 다음 같습니다이 마이그레이션이 이미 적용 된 기존 데이터베이스를 만들 수 것입니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-145">We’ll then make our existing database look like this migration has already been applied.</span></span>

1.  <span data-ttu-id="b4509-146">실행 합니다 **Add-migration InitialCreate** 패키지 관리자 콘솔에서 명령을 합니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-146">Run the **Add-Migration InitialCreate** command in Package Manager Console.</span></span> <span data-ttu-id="b4509-147">이 스키마를 만들려면 기존 마이그레이션을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-147">This creates a migration to create the existing schema.</span></span>
2.  <span data-ttu-id="b4509-148">새로 만든 마이그레이션의 최대 메서드의 모든 코드 주석 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-148">Comment out all code in the Up method of the newly created migration.</span></span> <span data-ttu-id="b4509-149">이렇게 하면 '적용' 마이그레이션을 로컬 데이터베이스에 모든 테이블 등 이미 존재 하는 다시 만들지 않고 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-149">This will allow us to ‘apply’ the migration to the local database without trying to recreate all the tables etc. that already exist.</span></span>
3.  <span data-ttu-id="b4509-150">실행 합니다 **Update-database** 패키지 관리자 콘솔에서 명령을 합니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-150">Run the **Update-Database** command in Package Manager Console.</span></span> <span data-ttu-id="b4509-151">InitialCreate 마이그레이션을 데이터베이스에 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-151">This will apply the InitialCreate migration to the database.</span></span> <span data-ttu-id="b4509-152">실제 마이그레이션 포함 되어 있지 않습니다 (에서는 일시적으로 주석 처리 된 수) 때문에 변경, 행을 추가 하기만 하면 됩니다 합니다 \_ \_MigrationsHistory 테이블 나타내는이 마이그레이션이 이미 적용 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-152">Since the actual migration doesn’t contain any changes (because we temporarily commented them out), it will simply add a row to the \_\_MigrationsHistory table indicating that this migration has already been applied.</span></span>
4.  <span data-ttu-id="b4509-153">최대 메서드의 코드에서에서 취소-주석입니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-153">Un-comment the code in the Up method.</span></span> <span data-ttu-id="b4509-154">즉,이 마이그레이션 이후 데이터베이스에 적용 될 때 로컬 데이터베이스에 이미 존재 하는 스키마가 마이그레이션 하 여 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-154">This means that when this migration is applied to future databases, the schema that already existed in the local database will be created by migrations.</span></span>

## <a name="things-to-be-aware-of"></a><span data-ttu-id="b4509-155">알아야 할 사항</span><span class="sxs-lookup"><span data-stu-id="b4509-155">Things to be aware of</span></span>

<span data-ttu-id="b4509-156">몇 가지 방법으로 기존 데이터베이스에 대 한 마이그레이션을 사용할 때 주의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-156">There are a few things you need to be aware of when using Migrations against an existing database.</span></span>

### <a name="defaultcalculated-names-may-not-match-existing-schema"></a><span data-ttu-id="b4509-157">기본/계산 이름을 기존 스키마와 일치 하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-157">Default/calculated names may not match existing schema</span></span>

<span data-ttu-id="b4509-158">마이그레이션은 마이그레이션을 스 캐 폴딩이 열 및 테이블 이름을 명시적으로 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-158">Migrations explicitly specifies names for columns and tables when it scaffolds a migrations.</span></span> <span data-ttu-id="b4509-159">그러나 마이그레이션을 적용 하는 경우 마이그레이션에 대 한 기본 이름이 계산 하는 다른 데이터베이스 개체가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-159">However, there are other database objects that Migrations calculates a default name for when applying the migrations.</span></span> <span data-ttu-id="b4509-160">인덱스와 foreign key 제약 조건이 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-160">This includes indexes and foreign key constraints.</span></span> <span data-ttu-id="b4509-161">기존 스키마를 대상으로 하는 경우 이러한 계산된 이름이 실제로 존재 하는 데이터베이스에서 일치 하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-161">When targeting an existing schema, these calculated names may not match what actually exists in your database.</span></span>

<span data-ttu-id="b4509-162">이러한 문제에 유의 해야 할 경우 몇 가지 예가 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-162">Here are some examples of when you need to be aware of this:</span></span>

<span data-ttu-id="b4509-163">**사용 하는 경우 ' 옵션 1: 기존 스키마를 사용 하 여 시작 지점으로 ' 3 단계에서에서:**</span><span class="sxs-lookup"><span data-stu-id="b4509-163">**If you used ‘Option One: Use existing schema as a starting point’ from Step 3:**</span></span>

-   <span data-ttu-id="b4509-164">향후 변경 내용을 모델에 필요한 변경 하거나 다르게 명명 된 데이터베이스 개체 중 하나를 삭제 하는 경우 올바른 이름을 지정 하는 스 캐 폴드 된 마이그레이션 수정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-164">If future changes in your model require changing or dropping one of the database objects that is named differently, you will need to modify the scaffolded migration to specify the correct name.</span></span> <span data-ttu-id="b4509-165">마이그레이션 Api에는 이렇게 할 수 있는 선택적 이름 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-165">The Migrations APIs have an optional Name parameter that allows you to do this.</span></span>
    <span data-ttu-id="b4509-166">예를 들어, 기존 스키마 IndexFk 라는 인덱스를 가진 BlogId 외래 키 열을 사용 하 여 Post 테이블 있을\_BlogId 합니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-166">For example, your existing schema may have a Post table with a BlogId foreign key column that has an index named IndexFk\_BlogId.</span></span> <span data-ttu-id="b4509-167">그러나 기본적으로 마이그레이션 기대 IX 이라는 이름으로이 인덱스\_BlogId 합니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-167">However, by default Migrations would expect this index to be named IX\_BlogId.</span></span> <span data-ttu-id="b4509-168">지정 된 IndexFk 스 캐 폴드 된 DropIndex 호출을 수정 해야이 인덱스를 삭제 하는 모델을 변경한 경우\_BlogId 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-168">If you make a change to your model that results in dropping this index, you will need to modify the scaffolded DropIndex call to specify the IndexFk\_BlogId name.</span></span>

<span data-ttu-id="b4509-169">**사용 하는 경우 ' 옵션 2: 시작 점으로 사용 하 여 빈 데이터베이스 ' 3 단계에서에서:**</span><span class="sxs-lookup"><span data-stu-id="b4509-169">**If you used ‘Option Two: Use empty database as a starting point’ from Step 3:**</span></span>

-   <span data-ttu-id="b4509-170">마이그레이션에서는 인덱스 및 잘못 된 이름을 사용 하 여 foreign key 제약 조건을 삭제 하려고 하 여 로컬 데이터베이스에 대해 초기 마이그레이션 (즉, 빈 데이터베이스를 되돌리기) 아래쪽 메서드를 실행 하는 동안 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-170">Trying to run the Down method of the initial migration (that is, reverting to an empty database) against your local database may fail because Migrations will try to drop indexes and foreign key constraints using the incorrect names.</span></span> <span data-ttu-id="b4509-171">다른 데이터베이스를 초기 마이그레이션의 최대 메서드를 사용 하 여 처음부터 만들 때문에이 로컬 데이터베이스에 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-171">This will only affect your local database since other databases will be created from scratch using the Up method of the initial migration.</span></span>
    <span data-ttu-id="b4509-172">빈 상태로 기존 로컬 데이터베이스를 다운 그레이드 하려면 데이터베이스를 삭제 하거나 모든 테이블을 삭제 하 여이 작업을 수행 하려면 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-172">If you want to downgrade your existing local database to an empty state it is easiest to do this manually, either by dropping the database or dropping all the tables.</span></span> <span data-ttu-id="b4509-173">이 초기 다운 그레이드 후 모든 데이터베이스 개체를 기본 이름으로 재생성 됩니다, 따라서이 문제를 제공 하지 않습니다 자체 다시 합니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-173">After this initial downgrade all database objects will be recreated with the default names, so this issue will not present itself again.</span></span>
-   <span data-ttu-id="b4509-174">향후 변경 내용을 모델에 필요한 변경 하거나 다르게 명명 된 데이터베이스 개체 중 하나를 삭제 하는 경우이 작동 하지 않습니다 – 기존 로컬 데이터베이스에 대해 이름을 기본값와 일치 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-174">If future changes in your model require changing or dropping one of the database objects that is named differently, this will not work against your existing local database – since the names won’t match the defaults.</span></span> <span data-ttu-id="b4509-175">그러나 마이그레이션 하 여 선택 된 기본 이름을 사용 하는 '부터' 생성 된 데이터베이스에 대해 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-175">However, it will work against databases that were created ‘from scratch’ since they will have used the default names chosen by Migrations.</span></span>
    <span data-ttu-id="b4509-176">로컬 기존 데이터베이스에서 이러한 변경을 수동으로 수행 또는 다른 컴퓨터 에서도 마이그레이션을부터 데이터베이스를 다시 고려할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-176">You could either make these changes manually on your local existing database, or consider having Migrations recreate your database from scratch – as it will on other machines.</span></span>
-   <span data-ttu-id="b4509-177">초기 마이그레이션 위쪽 메서드를 사용 하 여 만든 데이터베이스 수 약간과 다를 로컬 데이터베이스 인덱스에 대 한 계산 된 기본 이름을 이후 foreign key 제약 조건이 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-177">Databases created using the Up method of your initial migration may differ slightly from the local database since the calculated default names for indexes and foreign key constraints will be used.</span></span> <span data-ttu-id="b4509-178">얻게 될 수 있습니다도 추가 인덱스를 사용 하 여 마이그레이션을 기본적으로 외래 키 열에 인덱스를 만들는 –이 되지 않은 원래 로컬 데이터베이스의 경우 처럼 합니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-178">You may also end up with extra indexes as Migrations will create indexes on foreign key columns by default – this may not have been the case in your original local database.</span></span>

### <a name="not-all-database-objects-are-represented-in-the-model"></a><span data-ttu-id="b4509-179">일부 데이터베이스 개체는 모델에 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-179">Not all database objects are represented in the model</span></span>

<span data-ttu-id="b4509-180">데이터베이스 개체 모델의 일부분이 아닌 마이그레이션을 하 여 처리 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-180">Database objects that are not part of your model will not be handled by Migrations.</span></span> <span data-ttu-id="b4509-181">이 뷰, 저장된 프로시저, 권한, 모델, 추가 인덱스, 등 포함 되지 않은 테이블에 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-181">This can include views, stored procedures, permissions, tables that are not part of your model, additional indexes, etc.</span></span>

<span data-ttu-id="b4509-182">이러한 문제에 유의 해야 할 경우 몇 가지 예가 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-182">Here are some examples of when you need to be aware of this:</span></span>

-   <span data-ttu-id="b4509-183">옵션에 관계 없이 선택한 '3 단계의' 모델의 향후 변경 내용을 변경 하거나 마이그레이션은 이러한 변경을 수행 하지 못합니다 이러한 추가 개체를 삭제 해야 하는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-183">Regardless of the option you chose in ‘Step 3’, if future changes in your model require changing or dropping these additional objects Migrations will not know to make these changes.</span></span> <span data-ttu-id="b4509-184">예를 들어 추가 인덱스에 있는 열을 삭제 하는 경우 마이그레이션은 하지 못합니다 인덱스를 삭제 합니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-184">For example, if you drop a column that has an additional index on it, Migrations will not know to drop the index.</span></span> <span data-ttu-id="b4509-185">스 캐 폴드 된 마이그레이션에 수동으로 추가 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-185">You will need to manually add this to the scaffolded Migration.</span></span>
-   <span data-ttu-id="b4509-186">사용 하는 경우 ' 옵션 2: 시작 점으로 사용 하 여 빈 데이터베이스 ', 이러한 추가 개체 초기 마이그레이션의 최대 메서드에 의해 생성 되지 것입니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-186">If you used ‘Option Two: Use empty database as a starting point’, these additional objects will not be created by the Up method of your initial migration.</span></span>
    <span data-ttu-id="b4509-187">원하는 경우 이러한 추가 개체 주의 하는 메서드 및 위쪽을 수정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-187">You can modify the Up and Down methods to take care of these additional objects if you wish.</span></span> <span data-ttu-id="b4509-188">보기 – 예: 마이그레이션 api – 고유 하 게 지원 되지 않는 개체에 대해 사용할 수 있습니다 합니다 [Sql](https://msdn.microsoft.com/library/system.data.entity.migrations.dbmigration.sql.aspx) 하 만들기/삭제를 원시 SQL을 실행 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="b4509-188">For objects that are not natively supported in the Migrations API – such as views – you can use the [Sql](https://msdn.microsoft.com/library/system.data.entity.migrations.dbmigration.sql.aspx) method to run raw SQL to create/drop them.</span></span>
