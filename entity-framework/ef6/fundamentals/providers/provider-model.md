---
title: EF6-Entity Framework 6 공급자 모델을
author: divega
ms.date: 2018-06-27
ms.assetid: 066832F0-D51B-4655-8BE7-C983C557E0E4
ms.openlocfilehash: 7d9e2f49b9ef59fb63b024646911ec0d8dfcfc60
ms.sourcegitcommit: 0d36e8ff0892b7f034b765b15e041f375f88579a
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/09/2018
ms.locfileid: "44251106"
---
# <a name="the-entity-framework-6-provider-model"></a><span data-ttu-id="6c313-102">Entity Framework 6 공급자 모델</span><span class="sxs-lookup"><span data-stu-id="6c313-102">The Entity Framework 6 provider model</span></span>

<span data-ttu-id="6c313-103">Entity Framework 공급자 모델에는 Entity Framework 다양 한 유형의 데이터베이스 서버와 함께 사용 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-103">The Entity Framework provider model allows Entity Framework to be used with different types of database server.</span></span> <span data-ttu-id="6c313-104">예를 들어, EF EF Microsoft SQL Server Compact Edition에 대해 사용할 수 있도록 다른 공급자에 연결할 수 있습니다 하는 동안 Microsoft SQL Server에 대해 사용할 수 있도록 하나 이상의 공급자 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-104">For example, one provider can be plugged in to allow EF to be used against Microsoft SQL Server, while another provider can be plugged into to allow EF to be used against Microsoft SQL Server Compact Edition.</span></span> <span data-ttu-id="6c313-105">알고 있는 EF6의 공급자에서 찾을 수 있습니다 합니다 [Entity Framework 공급자](~/ef6/fundamentals/providers/index.md) 페이지입니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-105">The providers for EF6 that we are aware of can be found on the [Entity Framework providers](~/ef6/fundamentals/providers/index.md) page.</span></span>

<span data-ttu-id="6c313-106">EF EF는 오픈 소스 라이선스로 출시 될 수 있도록 공급자와 상호 작용 하는 방법은 특정 변경 했습니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-106">Certain changes were required to the way EF interacts with providers to allow EF to be released under an open source license.</span></span> <span data-ttu-id="6c313-107">이러한 변경 내용을 함께 공급자의 등록을 위한 새로운 메커니즘 EF6 어셈블리에 대해 EF 공급자를 다시 작성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-107">These changes require rebuilding of EF providers against the EF6 assemblies together with new mechanisms for registration of the provider.</span></span>

## <a name="rebuilding"></a><span data-ttu-id="6c313-108">다시 작성</span><span class="sxs-lookup"><span data-stu-id="6c313-108">Rebuilding</span></span>

<span data-ttu-id="6c313-109">EF6을 사용 하 여 아웃 외 (OOB) 어셈블리와 이전에.NET Framework의 일부인 핵심 코드가 이제 배송할 됩니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-109">With EF6 the core code that was previously part of the .NET Framework is now being shipped as out-of-band (OOB) assemblies.</span></span> <span data-ttu-id="6c313-110">EF6 응용 프로그램을 빌드하는 방법에 대 한 세부 정보에서 확인할 수 있습니다 합니다 [EF6 응용 프로그램 업데이트](~/ef6/what-is-new/upgrading-to-ef6.md) 페이지입니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-110">Details on how to build applications against EF6 can be found on the [Updating applications for EF6](~/ef6/what-is-new/upgrading-to-ef6.md) page.</span></span> <span data-ttu-id="6c313-111">공급자가 이러한 지침을 사용 하 여 다시 작성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-111">Providers will also need to be rebuilt using these instructions.</span></span>

## <a name="provider-types-overview"></a><span data-ttu-id="6c313-112">공급자 형식 개요</span><span class="sxs-lookup"><span data-stu-id="6c313-112">Provider types overview</span></span>

<span data-ttu-id="6c313-113">EF 공급자로 실제로 이러한 서비스 (대 한 기본 클래스)에서 확장 하거나 (인터페이스)를 구현 하는 CLR 형식으로 정의 하는 공급자 관련 서비스의 컬렉션.</span><span class="sxs-lookup"><span data-stu-id="6c313-113">An EF provider is really a collection of provider-specific services defined by CLR types that these services extend from (for a base class) or implement (for an interface).</span></span> <span data-ttu-id="6c313-114">이러한 서비스의 두 가지 기본적인 및 EF 전혀 작동 하는 데 필요한입니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-114">Two of these services are fundamental and necessary for EF to function at all.</span></span> <span data-ttu-id="6c313-115">다른 선택 사항이 며 특정 기능은 필수 및/또는 대상으로 지정 되는 특정 데이터베이스 서버에 이러한 서비스의 기본 구현이 작동 하지 않습니다 하는 경우에 구현 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-115">Others are optional and only need to be implemented if specific functionality is required and/or the default implementations of these services does not work for the specific database server being targeted.</span></span>

## <a name="fundamental-provider-types"></a><span data-ttu-id="6c313-116">기본 공급자 형식</span><span class="sxs-lookup"><span data-stu-id="6c313-116">Fundamental provider types</span></span>

### <a name="dbproviderfactory"></a><span data-ttu-id="6c313-117">DbProviderFactory</span><span class="sxs-lookup"><span data-stu-id="6c313-117">DbProviderFactory</span></span>

<span data-ttu-id="6c313-118">EF에서 파생 된 형식에 따라 달라 집니다 [System.Data.Common.DbProviderFactory](http://msdn.microsoft.com/en-us/library/system.data.common.dbproviderfactory.aspx) 기본적인 수준의 데이터베이스에 대 한 모든 액세스를 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-118">EF depends on having a type derived from [System.Data.Common.DbProviderFactory](http://msdn.microsoft.com/en-us/library/system.data.common.dbproviderfactory.aspx) for performing all low-level database access.</span></span> <span data-ttu-id="6c313-119">DbProviderFactory EF에 실제로 포함 되지 않지만 대신 클래스는 ADO.NET 공급자에 대 한 진입점을 제공 하는.NET Framework에 사용할 수 있습니다 다른 O/RMs EF 또는 응용 프로그램에서 직접 연결, 명령, 매개 변수 인스턴스를 얻는 및 공급자의 다른 ADO.NET 추상화 알 수 없는 방식으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-119">DbProviderFactory is not actually part of EF but is instead a class in the .NET Framework that serves an entry point for ADO.NET providers that can be used by EF, other O/RMs or directly by an application to obtain instances of connections, commands, parameters and other ADO.NET abstractions in a provider agnostic way.</span></span> <span data-ttu-id="6c313-120">DbProviderFactory에 대 한 자세한 정보는에서 찾을 수 합니다 [ADO.NET에 대 한 MSDN 설명서](http://msdn.microsoft.com/en-us/library/a6cd7c08.aspx)합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-120">More information about DbProviderFactory an be found in the [MSDN documentation for ADO.NET](http://msdn.microsoft.com/en-us/library/a6cd7c08.aspx).</span></span>

### <a name="dbproviderservices"></a><span data-ttu-id="6c313-121">DbProviderServices</span><span class="sxs-lookup"><span data-stu-id="6c313-121">DbProviderServices</span></span>

<span data-ttu-id="6c313-122">EF는 ADO.NET 공급자가 이미 제공 하는 기능을 기반으로 EF에 필요한 추가 기능을 제공 하는 데 DbProviderServices에서 파생 된 형식에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-122">EF depends on having a type derived from DbProviderServices for providing additional functionality needed by EF on top of the functionality already provided by the ADO.NET provider.</span></span> <span data-ttu-id="6c313-123">이전 버전의 EF DbProviderServices 클래스의.NET Framework 구성 요소 였으며 System.Data.Common 네임 스페이스에서 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-123">In older versions of EF the DbProviderServices class was part of the .NET Framework and was found in the System.Data.Common namespace.</span></span> <span data-ttu-id="6c313-124">EF6을 사용 하 여이 클래스는 이제 EntityFramework.dll의 일부 시작한 System.Data.Entity.Core.Common 네임 스페이스.</span><span class="sxs-lookup"><span data-stu-id="6c313-124">Starting with EF6 this class is now part of EntityFramework.dll and is in the System.Data.Entity.Core.Common namespace.</span></span>

<span data-ttu-id="6c313-125">DbProviderServices 구현의 기본 기능에 대 한 자세한 내용은에서 확인할 수 있습니다 [MSDN](http://msdn.microsoft.com/en-us/library/ee789835.aspx)합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-125">More details about the fundamental functionality of a DbProviderServices implementation can be found on [MSDN](http://msdn.microsoft.com/en-us/library/ee789835.aspx).</span></span> <span data-ttu-id="6c313-126">그러나이 정보를 작성 하는 시간을 기준으로 업데이트 되지 않았다는 EF6에 대 한 대부분의 개념은 여전히 유효 하지만 note 합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-126">However, note that as of the time of writing this information is not updated for EF6 although most of the concepts are still valid.</span></span> <span data-ttu-id="6c313-127">DbProviderServices의 SQL Server 및 SQL Server Compact 구현도 확인 됩니다에 [오픈 소스 코드 베이스](https://github.com/aspnet/EntityFramework6/) 및 다른 구현에 대 한 유용한 참조로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-127">The SQL Server and SQL Server Compact implementations of DbProviderServices are also checked into to the [open-source codebase](https://github.com/aspnet/EntityFramework6/) and can serve as useful references for other implementations.</span></span>

<span data-ttu-id="6c313-128">이전 버전의 EF DbProviderServices 구현은 사용 하는 ADO.NET 공급자에서 직접 가져온 합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-128">In older versions of EF the DbProviderServices implementation to use was obtained directly from an ADO.NET provider.</span></span> <span data-ttu-id="6c313-129">이 작업은 DbProviderFactory를 IServiceProvider로 캐스팅 하 고 GetService 메서드를 호출 하 여 수행 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-129">This was done by casting DbProviderFactory to IServiceProvider and calling the GetService method.</span></span> <span data-ttu-id="6c313-130">이 DbProviderFactory를 EF 공급자 긴밀 하 게 결합 합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-130">This tightly coupled the EF provider to the DbProviderFactory.</span></span> <span data-ttu-id="6c313-131">이 결합에서.NET Framework 외부로 이동 되 고 EF를 차단 하 고 따라서 EF6에 대 한 밀접 한 결합이 제거 되었습니다 DbProviderServices 구현의 응용 프로그램의 구성 파일에서 직접 또는 코드 기반에 지금 등록 좀 더 자세히 설명 된 대로 구성 합니다 _DbProviderServices 등록_ 아래의 섹션입니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-131">This coupling blocked EF from being moved out of the .NET Framework and therefore for EF6 this tight coupling has been removed and an implementation of DbProviderServices is now registered directly in the application’s configuration file or in code-based configuration as described in more detail the _Registering DbProviderServices_ section below.</span></span>

## <a name="additional-services"></a><span data-ttu-id="6c313-132">추가 서비스</span><span class="sxs-lookup"><span data-stu-id="6c313-132">Additional services</span></span>

<span data-ttu-id="6c313-133">위에서 설명한 기본적인 서비스 외에도 많은 다른 서비스 EF에서 사용 하는 경우에 따라 또는 항상 공급자별도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-133">In addition to the fundamental services described above there are also many other services used by EF which are either always or sometimes provider-specific.</span></span> <span data-ttu-id="6c313-134">이러한 서비스의 기본 공급자별 구현은 DbProviderServices 구현으로 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-134">Default provider-specific implementations of these services can be supplied by a DbProviderServices implementation.</span></span> <span data-ttu-id="6c313-135">응용 프로그램도 이러한 서비스의 구현 재정의 하거나 DbProviderServices 형식 기본값을 제공 하지 않는 경우에 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-135">Applications can also override the implementations of these services, or provide implementations when a DbProviderServices type does not provide a default.</span></span> <span data-ttu-id="6c313-136">자세히 설명 되어이 _추가 서비스 확인_ 아래의 섹션입니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-136">This is described in more detail in the _Resolving additional services_ section below.</span></span>

<span data-ttu-id="6c313-137">공급자 공급자에 유용할 수 있는 추가 서비스 형식은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-137">The additional service types that a provider may be of interest to a provider are listed below.</span></span> <span data-ttu-id="6c313-138">이러한 각 유형의 서비스에 대 한 자세한 내용은 API 설명서에서 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-138">More details about each of these service types can be found in the API documentation.</span></span>

### <a name="idbexecutionstrategy"></a><span data-ttu-id="6c313-139">IDbExecutionStrategy</span><span class="sxs-lookup"><span data-stu-id="6c313-139">IDbExecutionStrategy</span></span>

<span data-ttu-id="6c313-140">이 쿼리와 명령을 데이터베이스에 대해 실행 될 때 다시 시도 하거나 다른 동작을 구현 하는 공급자 수 있는 선택적 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-140">This is an optional service that allows a provider to implement retries or other behavior when queries and commands are executed against the database.</span></span> <span data-ttu-id="6c313-141">구현이 제공 하는 경우 다음 EF 단순히 명령을 실행 하 여를 throw 된 예외를 전파 합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-141">If no implementation is provided, then EF will simply execute the commands and propagate any exceptions thrown.</span></span> <span data-ttu-id="6c313-142">SQL Server에 대 한이 서비스는 SQL Azure 같은 클라우드 기반 데이터베이스 서버에 대해 실행할 때 특히 유용 하며 재시도 정책을 제공에 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-142">For SQL Server this service is used to provide a retry policy which is especially useful when running against cloud-based database servers such as SQL Azure.</span></span>

### <a name="idbconnectionfactory"></a><span data-ttu-id="6c313-143">IDbConnectionFactory</span><span class="sxs-lookup"><span data-stu-id="6c313-143">IDbConnectionFactory</span></span>

<span data-ttu-id="6c313-144">이 공급자는 데이터베이스 이름만 지정 하는 경우 규칙에 따라 DbConnection 개체를 만들 수 있도록 하는 선택적 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-144">This is an optional service that allows a provider to create DbConnection objects by convention when given only a database name.</span></span> <span data-ttu-id="6c313-145">이 서비스 하는 동안 DbProviderServices 구현 EF 4.1 이후 제공 된 고도 설정할 수 있습니다 명시적으로 구성 파일 또는 코드에서 확인할 수 있는 참고 합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-145">Note that while this service can be resolved by a DbProviderServices implementation it has been present since EF 4.1 and can also be explicitly set in either the config file or in code.</span></span> <span data-ttu-id="6c313-146">공급자만을 기본 공급자로 등록 하는 경우이 서비스를 해결할 기회 받습니다 (참조 _기본 공급자_ 아래) 기본 연결 팩터리가 설정 되어 있지 않은 다른 곳에서 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="6c313-146">The provider will only get a chance to resolve this service if it registered as the default provider (see _The default provider_ below) and if a default connection factory has not been set elsewhere.</span></span>

### <a name="dbspatialservices"></a><span data-ttu-id="6c313-147">DbSpatialServices</span><span class="sxs-lookup"><span data-stu-id="6c313-147">DbSpatialServices</span></span>

<span data-ttu-id="6c313-148">Geography 및 geometry 공간 형식에 대 한 지원을 추가할 공급자를 허용 하는 선택적 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-148">This is an optional services that allows a provider to add support for geography and geometry spatial types.</span></span> <span data-ttu-id="6c313-149">이 서비스의 구현은 공간 형식을 사용 하 여 EF를 사용 하도록 응용 프로그램에 대 한 순서로 제공 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-149">An implementation of this service must be supplied in order for an application to use EF with spatial types.</span></span> <span data-ttu-id="6c313-150">DbSptialServices에 대 한 두 가지 방식에서 하 라는 메시지가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-150">DbSptialServices is asked for in two ways.</span></span> <span data-ttu-id="6c313-151">첫째, 공급자별 공간 서비스 DbProviderInfo 개체를 사용 하 여 요청 된 (invariant를 포함 하는 이름 및 매니페스트 토큰) 키로 합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-151">First, provider-specific spatial services are requested using a DbProviderInfo object (which contains invariant name and manifest token) as key.</span></span> <span data-ttu-id="6c313-152">둘째, 키가 없는 DbSpatialServices에 요청할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-152">Second, DbSpatialServices can be asked for with no key.</span></span> <span data-ttu-id="6c313-153">해결 "전역 공간 공급자" 독립 실행형 DbGeography 또는 DbGeometry 유형을 만들 때 사용 되는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-153">This is used to resolve the “global spatial provider” that is used when creating stand-alone DbGeography or DbGeometry types.</span></span>

### <a name="migrationsqlgenerator"></a><span data-ttu-id="6c313-154">MigrationSqlGenerator</span><span class="sxs-lookup"><span data-stu-id="6c313-154">MigrationSqlGenerator</span></span>

<span data-ttu-id="6c313-155">이것이 EF 마이그레이션을 만들고 데이터베이스 스키마 수정에 사용 되는 SQL 생성에 대 한 Code First에서 사용할 수 있는 선택적 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-155">This is an optional service that allows EF Migrations to be used for the generation of SQL used in creating and modifying database schemas by Code First.</span></span> <span data-ttu-id="6c313-156">구현을은 마이그레이션을 지원 하기 위해 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-156">An implementation is required in order to support Migrations.</span></span> <span data-ttu-id="6c313-157">구현을 제공 하는 경우 다음 것도 사용 됩니다 Database.Create 메서드나 데이터베이스 이니셜라이저를 사용 하 여 데이터베이스를 만들 때.</span><span class="sxs-lookup"><span data-stu-id="6c313-157">If an implementation is provided then it will also be used when databases are created using database initializers or the Database.Create method.</span></span>

### <a name="funcdbconnection-string-historycontextfactory"></a><span data-ttu-id="6c313-158">Func < DbConnection, HistoryContextFactory 문자열 ></span><span class="sxs-lookup"><span data-stu-id="6c313-158">Func<DbConnection, string, HistoryContextFactory></span></span>

<span data-ttu-id="6c313-159">이 공급자를 HistoryContext의 매핑을 구성할 수 있도록 하는 선택적 서비스를 `__MigrationHistory` EF 마이그레이션을 사용 하는 테이블입니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-159">This is an optional service that allows a provider to configure the mapping of the HistoryContext to the `__MigrationHistory` table used by EF Migrations.</span></span> <span data-ttu-id="6c313-160">HistoryContext 코드 첫 번째 DbContext 되며 테이블 및 열 매핑 사양 이름과 같은 항목을 변경 하려면 일반 흐름 API를 사용 하 여 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-160">The HistoryContext is a Code First DbContext and can be configured using the normal fluent API to change things like the name of the table and the column mapping specifications.</span></span> <span data-ttu-id="6c313-161">해당 공급자에서 모든 기본 테이블 및 열 매핑을 지 원하는 경우 지정 된 데이터베이스 서버에 대 한 모든 공급자에 대 한 EF를 반환한이 서비스의 기본 구현을 작동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-161">The default implementation of this service returned by EF for all providers may work for a given database server if all the default table and column mappings are supported by that provider.</span></span> <span data-ttu-id="6c313-162">이 경우 공급자는이 서비스의 구현을 제공 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-162">In such a case the provider does not need to supply an implementation of this service.</span></span>

### <a name="idbproviderfactoryresolver"></a><span data-ttu-id="6c313-163">IDbProviderFactoryResolver</span><span class="sxs-lookup"><span data-stu-id="6c313-163">IDbProviderFactoryResolver</span></span>

<span data-ttu-id="6c313-164">이것이 지정된 DbConnection 개체에서 올바른 dbproviderfactory에 대 한 선택적 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-164">This is an optional service for obtaining the correct DbProviderFactory from a given DbConnection object.</span></span> <span data-ttu-id="6c313-165">모든 공급자에 대 한 EF를 반환한이 서비스의 기본 구현은 모든 공급자에 대해 작동 됩니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-165">The default implementation of this service returned by EF for all providers is intended to work for all providers.</span></span> <span data-ttu-id="6c313-166">그러나.NET 4를 실행 하는 경우는 DbProviderFactory 공개적으로 액세스할 수 없는 경우 1에서 해당 DbConnections 합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-166">However, when running on .NET 4, the DbProviderFactory is not publicly accessible from one if its DbConnections.</span></span> <span data-ttu-id="6c313-167">따라서 EF 일부 추론을 사용 하 여 일치 하는 것에 등록된 된 공급자를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-167">Therefore, EF uses some heuristics to search the registered providers to find a match.</span></span> <span data-ttu-id="6c313-168">일부 공급자에 대 한 이러한 추론이 실패 하 고 이러한 상황에서는 공급자에는 새 구현을 제공 해야는 가능성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-168">It is possible that for some providers these heuristics will fail and in such situations the provider should supply a new implementation.</span></span>

## <a name="registering-dbproviderservices"></a><span data-ttu-id="6c313-169">DbProviderServices 등록</span><span class="sxs-lookup"><span data-stu-id="6c313-169">Registering DbProviderServices</span></span>

<span data-ttu-id="6c313-170">DbProviderServices 구현은 사용 하는 응용 프로그램의 구성 파일 (app.config 또는 web.config) 또는 코드 기반 구성을 사용 하 여 등록할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-170">The DbProviderServices implementation to use can be registered either in the application’s configuration file (app.config or web.config) or using code-based configuration.</span></span> <span data-ttu-id="6c313-171">두 경우 모두 등록 공급자의 "고정 이름" 키로 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-171">In either case the registration uses the provider’s “invariant name” as a key.</span></span> <span data-ttu-id="6c313-172">따라서 여러 공급자를를 등록 하 고 단일 응용 프로그램에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-172">This allows multiple providers to be registered and used in a single application.</span></span> <span data-ttu-id="6c313-173">고정 이름 EF 등록에 사용 되는 ADO.NET 공급자 등록 및 연결 문자열에 사용 되는 고정 이름을와 같습니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-173">The invariant name used for EF registrations is the same as the invariant name used for ADO.NET provider registration and connection strings.</span></span> <span data-ttu-id="6c313-174">예를 들어, SQL Server 고정 이름 "System.Data.SqlClient" 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-174">For example, for SQL Server the invariant name “System.Data.SqlClient” is used.</span></span>

### <a name="config-file-registration"></a><span data-ttu-id="6c313-175">구성 파일 등록</span><span class="sxs-lookup"><span data-stu-id="6c313-175">Config file registration</span></span>

<span data-ttu-id="6c313-176">DbProviderServices 형식은 사용 하는 응용 프로그램의 구성 파일의 entityFramework 섹션의 공급자 목록에서 요소를으로 등록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-176">The DbProviderServices type to use is registered as a provider element in the providers list of the entityFramework section of the application’s config file.</span></span> <span data-ttu-id="6c313-177">예를 들어:</span><span class="sxs-lookup"><span data-stu-id="6c313-177">For example:</span></span>

``` xml
<entityFramework>
  <providers>
    <provider invariantName="My.Invariant.Name" type="MyProvider.MyProviderServices, MyAssembly" />
  </providers>
</entityFramework>
```

<span data-ttu-id="6c313-178">합니다 _형식_ 문자열 사용할 DbProviderServices 구현의 정규화 된 어셈블리 형식 이름 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-178">The _type_ string must be the assembly-qualified type name of the DbProviderServices implementation to use.</span></span>

### <a name="code-based-registration"></a><span data-ttu-id="6c313-179">코드 기반 등록</span><span class="sxs-lookup"><span data-stu-id="6c313-179">Code-based registration</span></span>

<span data-ttu-id="6c313-180">EF6 공급자를 사용 하 여 시작 수 등록 코드를 사용 하 여.</span><span class="sxs-lookup"><span data-stu-id="6c313-180">Starting with EF6 providers can also be registered using code.</span></span> <span data-ttu-id="6c313-181">이렇게 하면 EF 공급자를 응용 프로그램의 구성 파일을 변경 하지 않고 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-181">This allows an EF provider to be used without any change to the application’s configuration file.</span></span> <span data-ttu-id="6c313-182">코드 기반 구성을 사용 하려면 응용 프로그램 클래스를 만들어야 DbConfiguration에 설명 된 대로 합니다 [코드 기반 구성 설명서](http://msdn.com/data/jj680699)합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-182">To use code-based configuration an application should create a DbConfiguration class as described in the [code-based configuration documentation](http://msdn.com/data/jj680699).</span></span> <span data-ttu-id="6c313-183">DbConfiguration 클래스의 생성자 EF 공급자를 등록 하는 SetProviderServices 호출 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-183">The constructor of the DbConfiguration class should then call SetProviderServices to register the EF provider.</span></span> <span data-ttu-id="6c313-184">예를 들어:</span><span class="sxs-lookup"><span data-stu-id="6c313-184">For example:</span></span>

``` csharp
public class MyConfiguration : DbConfiguration
{
    public MyConfiguration()
    {
        SetProviderServices("My.New.Provider", new MyProviderServices());
    }
}
```

## <a name="resolving-additional-services"></a><span data-ttu-id="6c313-185">추가 서비스 확인</span><span class="sxs-lookup"><span data-stu-id="6c313-185">Resolving additional services</span></span>

<span data-ttu-id="6c313-186">위에서 설명한 것 처럼 합니다 _공급자 형식 개요_ 섹션을 DbProviderServices 클래스 추가 서비스 확인에 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-186">As mentioned above in the _Provider types overview_ section, a DbProviderServices class can also be used to resolve additional services.</span></span> <span data-ttu-id="6c313-187">DbProviderServices IDbDependencyResolver 구현 및 등록 된 각 DbProviderServices 형식 "기본 해결 프로그램"으로 추가 됩니다 때문에 이것이 가능 합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-187">This is possible because DbProviderServices implements IDbDependencyResolver and each registered DbProviderServices type is added as a “default resolver”.</span></span> <span data-ttu-id="6c313-188">IDbDpendencyResolver 메커니즘에서 자세히 설명 되어 [종속성 확인](~/ef6/fundamentals/configuring/dependency-resolution.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-188">The IDbDpendencyResolver mechanism is described in more detail in [Dependency Resolution](~/ef6/fundamentals/configuring/dependency-resolution.md).</span></span> <span data-ttu-id="6c313-189">그러나 추가 서비스 공급자를 해결 하려면이 사양에서 모든 개념을 이해 하는 데 필요한 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-189">However, it is not necessary to understand all the concepts in this specification to resolve additional services in a provider.</span></span>

<span data-ttu-id="6c313-190">추가 서비스를 확인 하는 공급자에 대 한 가장 일반적인 방법은 DbProviderServices 클래스의 생성자에서 각 서비스에 대 한 DbProviderServices.AddDependencyResolver를 호출 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-190">The most common way for a provider to resolve additional services is to call DbProviderServices.AddDependencyResolver for each service in the constructor of the DbProviderServices class.</span></span> <span data-ttu-id="6c313-191">예를 들어 SqlProviderServices (SQL Server에 대 한 EF 공급자)는 초기화를 위해 다음과 유사한 코드에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-191">For example, SqlProviderServices (the EF provider for SQL Server) has code similar to this for initialization:</span></span>

``` csharp
private SqlProviderServices()
{
    AddDependencyResolver(new SingletonDependencyResolver<IDbConnectionFactory>(
        new SqlConnectionFactory()));

    AddDependencyResolver(new ExecutionStrategyResolver<DefaultSqlExecutionStrategy>(
        "System.data.SqlClient", null, () => new DefaultSqlExecutionStrategy()));

    AddDependencyResolver(new SingletonDependencyResolver<Func<MigrationSqlGenerator>>(
        () => new SqlServerMigrationSqlGenerator(), "System.data.SqlClient"));

    AddDependencyResolver(new SingletonDependencyResolver<DbSpatialServices>(
        SqlSpatialServices.Instance,
        k =>
        {
            var asSpatialKey = k as DbProviderInfo;
            return asSpatialKey == null
                || asSpatialKey.ProviderInvariantName == ProviderInvariantName;
        }));
}
```

<span data-ttu-id="6c313-192">이 생성자는 다음 도우미 클래스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-192">This constructor uses the following helper classes:</span></span>

*   <span data-ttu-id="6c313-193">SingletonDependencyResolver: 단일 서비스를 확인 하는 간단한 방법을 제공-동일한 인스턴스에 반환 되는 각 시간 GetService 호출 되도록 하는 서비스 이므로 합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-193">SingletonDependencyResolver: provides a simple way to resolve Singleton services—that is, services for which the same instance is returned each time that GetService is called.</span></span> <span data-ttu-id="6c313-194">일시적인 서비스는 요청 시 일시적인 인스턴스를 만들려면 사용할 단일 팩터리로 종종 등록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-194">Transient services are often registered as a singleton factory that will be used to create transient instances on demand.</span></span>
*   <span data-ttu-id="6c313-195">ExecutionStrategyResolver: 확인자를 관련 IExecutionStrategy 구현을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-195">ExecutionStrategyResolver: a resolver specific to returning IExecutionStrategy implementations.</span></span>

<span data-ttu-id="6c313-196">DbProviderServices.AddDependencyResolver를 사용 하는 대신 DbProviderServices.GetService를 재정의 하 고 추가 서비스를 직접 해결할 수 이기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-196">Instead of using DbProviderServices.AddDependencyResolver it is also possible to override DbProviderServices.GetService and resolve additional services directly.</span></span> <span data-ttu-id="6c313-197">EF 및 정의 된 특정 형식으로, 경우에 따라 지정된 된 키에 대 한 서비스 해야 하는 경우이 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-197">This method will be called when EF needs a service defined by a certain type and, in some cases, for a given key.</span></span> <span data-ttu-id="6c313-198">메서드는 수 또는 옵트아웃 서비스를 반환 하려면 null을 반환 하 고 대신 문제를 해결 하는 다른 클래스를 허용 하는 경우 서비스를 반환 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-198">The method should return the service if it can, or return null to opt-out of returning the service and instead allow another class to resolve it.</span></span> <span data-ttu-id="6c313-199">예를 들어, 기본 연결 팩터리를 해결 하려면 GetService의 코드 다음과 같이</span><span class="sxs-lookup"><span data-stu-id="6c313-199">For example, to resolve the default connection factory the code in GetService might look something like this:</span></span>

``` csharp
public override object GetService(Type type, object key)
{
    if (type == typeof(IDbConnectionFactory))
    {
        return new SqlConnectionFactory();
    }
    return null;
}
```

### <a name="registration-order"></a><span data-ttu-id="6c313-200">등록 순서</span><span class="sxs-lookup"><span data-stu-id="6c313-200">Registration order</span></span>

<span data-ttu-id="6c313-201">여러 DbProviderServices 구현을 응용 프로그램의 구성 파일에 등록 된 경우 나열 된 순서로 보조 확인자로 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-201">When multiple DbProviderServices implementations are registered in an application’s config file they will be added as secondary resolvers in the order that they are listed.</span></span> <span data-ttu-id="6c313-202">확인자 항상 추가 되는 보조 확인자 체인의 맨 위에 즉, 목록의 끝에 공급자를 다른 종속 해결할 기회를 받게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-202">Since resolvers are always added to the top of the secondary resolver chain this means that the provider at the end of the list will get a chance to resolve dependencies before the others.</span></span> <span data-ttu-id="6c313-203">(처음에 약간 낯설고 보일 수 있지만 각 공급자 목록에서 가져와 기존 공급자 위에 쌓는 상상할 하는 경우는 것이 좋습니다.)</span><span class="sxs-lookup"><span data-stu-id="6c313-203">(This can seem a little counter-intuitive at first, but it makes sense if you imagine taking each provider out of the list and stacking it on top of the existing providers.)</span></span>

<span data-ttu-id="6c313-204">이 정렬은 일반적으로 문제가 되지 않습니다 대부분의 공급자 서비스 공급자 및 공급자 고정 이름으로 키가 지정 되므로 합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-204">This ordering usually doesn’t matter because most provider services are provider-specific and keyed by provider invariant name.</span></span> <span data-ttu-id="6c313-205">그러나 서비스에 대 한는 하지 키가 지정 된 공급자 고정 이름 또는 일부 기타 공급자별 키 서비스 해결 될 예정이 순서에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-205">However, for services that are not keyed by provider invariant name or some other provider-specific key the service will be resolved based on this ordering.</span></span> <span data-ttu-id="6c313-206">예를 들어 설정 되지 않은 명시적으로 다르게 어딘가에 그렇지 않으면, 경우 기본 연결 팩터리는 체인의 맨 위에 있는 공급자 로부터 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-206">For example, if it is not explicitly set differently somewhere else, then the default connection factory will come from the topmost provider in the chain.</span></span>

## <a name="additional-config-file-registrations"></a><span data-ttu-id="6c313-207">추가 구성 파일 등록</span><span class="sxs-lookup"><span data-stu-id="6c313-207">Additional config file registrations</span></span>

<span data-ttu-id="6c313-208">명시적으로 일부 응용 프로그램의 구성 파일에서 직접 위에서 설명한 추가 공급자 서비스를 등록 하는 것이 가능 합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-208">It is possible to explicitly register some of the additional provider services described above directly in an application’s config file.</span></span> <span data-ttu-id="6c313-209">이 구성 파일의 등록을 완료 되 면 DbProviderServices 구현의 GetService 메서드를 반환한 모든 대신 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-209">When this is done the registration in the config file will be used instead of anything returned by the GetService method of the DbProviderServices implementation.</span></span>

### <a name="registering-the-default-connection-factory"></a><span data-ttu-id="6c313-210">기본 연결 팩터리를 등록합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-210">Registering the default connection factory</span></span>

<span data-ttu-id="6c313-211">부터 EF5 EntityFramework NuGet 패키지가 자동으로 SQL Express 연결 팩터리 또는 LocalDb 연결 팩터리 구성 파일에 등록 합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-211">Starting with EF5 the EntityFramework NuGet package automatically registered either the SQL Express connection factory or the LocalDb connection factory in the config file.</span></span>

<span data-ttu-id="6c313-212">예를 들어:</span><span class="sxs-lookup"><span data-stu-id="6c313-212">For example:</span></span>

``` xml
<entityFramework>
  <defaultConnectionFactory type="System.Data.Entity.Infrastructure.SqlConnectionFactory, EntityFramework" >
</entityFramework>
```

<span data-ttu-id="6c313-213">합니다 _형식_ IDbConnectionFactory를 구현 해야 하는 기본 연결 팩터리는에 대 한 어셈블리의 정규화 된 유형 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-213">The _type_ is the assembly-qualified type name for the default connection factory, which must implement IDbConnectionFactory.</span></span>

<span data-ttu-id="6c313-214">공급자 NuGet 패키지를 설치 하는 경우이 방식으로 기본 연결 팩터리를 설정 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-214">It is recommended that a provider NuGet package set the default connection factory in this way when installed.</span></span> <span data-ttu-id="6c313-215">참조 _공급자에 대 한 NuGet 패키지_ 아래.</span><span class="sxs-lookup"><span data-stu-id="6c313-215">See _NuGet Packages for providers_ below.</span></span>

## <a name="additional-ef6-provider-changes"></a><span data-ttu-id="6c313-216">추가 된 EF6 공급자 변경</span><span class="sxs-lookup"><span data-stu-id="6c313-216">Additional EF6 provider changes</span></span>

### <a name="spatial-provider-changes"></a><span data-ttu-id="6c313-217">공간 공급자가 변경</span><span class="sxs-lookup"><span data-stu-id="6c313-217">Spatial provider changes</span></span>

<span data-ttu-id="6c313-218">이제 공간 형식을 지 원하는 공급자 DbSpatialDataReader에서 파생 된 클래스에 일부 추가 메서드를 구현 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-218">Providers that support spatial types must now implement some additional methods on classes deriving from DbSpatialDataReader:</span></span>

*   `public abstract bool IsGeographyColumn(int ordinal)`
*   `public abstract bool IsGeometryColumn(int ordinal)`

<span data-ttu-id="6c313-219">기본 구현은 동기 메서드를 대리자로 위임 하 고 따라서 실행 하지 않도록 비동기적으로 재정의 될 것을 권장 하는 기존 메서드의 비동기 버전을 새 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-219">There are also new asynchronous versions of existing methods that are recommended to be overridden as the default implementations delegate to the synchronous methods and therefore do not execute asynchronously:</span></span>

*   `public virtual Task<DbGeography> GetGeographyAsync(int ordinal, CancellationToken cancellationToken)`
*   `public virtual Task<DbGeometry> GetGeometryAsync(int ordinal, CancellationToken cancellationToken)`

### <a name="native-support-for-enumerablecontains"></a><span data-ttu-id="6c313-220">Enumerable.Contains에 대 한 기본 지원</span><span class="sxs-lookup"><span data-stu-id="6c313-220">Native support for Enumerable.Contains</span></span>

<span data-ttu-id="6c313-221">EF6은 DbInExpression Enumerable.Contains LINQ 쿼리에서 사용 관련 성능 문제를 해결 하려면 추가 된 새로운 식 형식을 소개 합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-221">EF6 introduces a new expression type, DbInExpression, which was added to address performance issues around use of Enumerable.Contains in LINQ queries.</span></span> <span data-ttu-id="6c313-222">DbProviderManifest 클래스에는 새 가상 메서드로 SupportsInExpression 공급자가 새로운 식 형식을 처리 하는 경우를 확인 하려면 EF에서 호출 하는.</span><span class="sxs-lookup"><span data-stu-id="6c313-222">The DbProviderManifest class has a new virtual method, SupportsInExpression, which is called by EF to determine if a provider handles the new expression type.</span></span> <span data-ttu-id="6c313-223">기존 공급자 구현 사용 하 여 호환성에 대 한 메서드에서 false를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-223">For compatibility with existing provider implementations the method returns false.</span></span> <span data-ttu-id="6c313-224">이러한 향상 된이 기능을 활용할 수 EF6 공급자로 DbInExpression 처리 SupportsInExpression true를 반환 하도록 재정의 하는 코드를 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-224">To benefit from this improvement, an EF6 provider can add code to handle DbInExpression and override SupportsInExpression to return true.</span></span> <span data-ttu-id="6c313-225">DbInExpression 인스턴스의 DbExpressionBuilder.In 메서드를 호출 하 여 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-225">An instance of DbInExpression can be created by calling the DbExpressionBuilder.In method.</span></span> <span data-ttu-id="6c313-226">일반적으로 일치 항목을 테스트 하려면 DbConstantExpression 목록 및 테이블 열을 나타내는 DbExpression DbInExpression 인스턴스 구성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-226">A DbInExpression instance is composed of a DbExpression, usually representing a table column, and a list of DbConstantExpression to test for a match.</span></span>

## <a name="nuget-packages-for-providers"></a><span data-ttu-id="6c313-227">공급자에 대 한 NuGet 패키지</span><span class="sxs-lookup"><span data-stu-id="6c313-227">NuGet packages for providers</span></span>

<span data-ttu-id="6c313-228">EF6 공급자를 사용할 수 있도록 하나의 방법은 NuGet 패키지로 릴리스 것입니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-228">One way to make an EF6 provider available is to release it as a NuGet package.</span></span> <span data-ttu-id="6c313-229">NuGet 패키지를 사용 하 여 다음과 같은 이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-229">Using a NuGet package has the following advantages:</span></span>

*   <span data-ttu-id="6c313-230">사용 하기 쉬운 NuGet 공급자 등록 응용 프로그램의 구성 파일에 추가 하는 것</span><span class="sxs-lookup"><span data-stu-id="6c313-230">It is easy to use NuGet to add the provider registration to the application’s config file</span></span>
*   <span data-ttu-id="6c313-231">추가로 변경할 수 있습니다 구성 파일에 연결 규칙에는 등록 된 공급자를 사용 하 여 기본 연결 팩터리를 설정 하려면</span><span class="sxs-lookup"><span data-stu-id="6c313-231">Additional changes can be made to the config file to set the default connection factory so that connections made by convention will use the registered provider</span></span>
*   <span data-ttu-id="6c313-232">NuGet은 EF6 공급자 계속 새 EF 패키지 해제 된 후에 작동 되도록 바인딩 리디렉션을 추가 처리</span><span class="sxs-lookup"><span data-stu-id="6c313-232">NuGet handles adding binding redirects so that the EF6 provider should continue to work even after a new EF package is released</span></span>

<span data-ttu-id="6c313-233">이 예로 EntityFramework.SqlServerCompact 패키지에 포함 되는 [오픈 소스 코드 베이스](http://github.com/aspnet/entityframework6)합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-233">An example of this is the EntityFramework.SqlServerCompact package which is included in the [open source codebase](http://github.com/aspnet/entityframework6).</span></span> <span data-ttu-id="6c313-234">이 패키지는 EF 공급자 NuGet 패키지를 만들기 위한 좋은 템플릿으로 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-234">This package provides a good template for creating EF provider NuGet packages.</span></span>

### <a name="powershell-commands"></a><span data-ttu-id="6c313-235">PowerShell 명령</span><span class="sxs-lookup"><span data-stu-id="6c313-235">PowerShell commands</span></span>

<span data-ttu-id="6c313-236">EntityFramework NuGet 패키지를 설치한 경우에 공급자 패키지에 대 한 매우 유용한 두 개의 명령이 포함 된 PowerShell 모듈을 등록 합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-236">When the EntityFramework NuGet package is installed it registers a PowerShell module that contains two commands that are very useful for provider packages:</span></span>

*   <span data-ttu-id="6c313-237">추가 EFProvider 대상 프로젝트의 구성 파일에서 공급자에 대 한 새 엔터티를 추가 하 고 등록 된 공급자 목록 끝에는 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-237">Add-EFProvider adds a new entity for the provider in the target project’s configuration file and makes sure it is at the end of the list of registered providers.</span></span>
*   <span data-ttu-id="6c313-238">추가 EFDefaultConnectionFactory 추가 하거나 대상 프로젝트의 구성 파일에서 defaultConnectionFactory 등록을 업데이트 합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-238">Add-EFDefaultConnectionFactory either adds or updates the defaultConnectionFactory registration in the target project’s configuration file.</span></span>

<span data-ttu-id="6c313-239">이러한 명령을 구성 파일에는 entityFramework 섹션을 추가 하 고 필요한 경우 공급자 컬렉션을 추가 주의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-239">Both these commands take care of adding an entityFramework section to the config file and adding a providers collection if necessary.</span></span>

<span data-ttu-id="6c313-240">Install.ps1 NuGet 스크립트에서에서 이러한 명령을 호출할 수는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-240">It is intended that these commands be called from the install.ps1 NuGet script.</span></span> <span data-ttu-id="6c313-241">예를 들어, SQL Compact 공급자는 install.ps1이 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-241">For example, install.ps1 for the SQL Compact provider looks similar to this:</span></span>

``` powershell
param($installPath, $toolsPath, $package, $project)
Add-EFDefaultConnectionFactory $project 'System.Data.Entity.Infrastructure.SqlCeConnectionFactory, EntityFramework' -ConstructorArguments 'System.Data.SqlServerCe.4.0'
Add-EFProvider $project 'System.Data.SqlServerCe.4.0' 'System.Data.Entity.SqlServerCompact.SqlCeProviderServices, EntityFramework.SqlServerCompact'</pre>
```

<span data-ttu-id="6c313-242">패키지 관리자 콘솔 창에서 get-help를 사용 하 여 이러한 명령에 대 한 자세한 정보를 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-242">More information about these commands can be obtained by using get-help in the Package Manager Console window.</span></span>

## <a name="wrapping-providers"></a><span data-ttu-id="6c313-243">래핑 공급자</span><span class="sxs-lookup"><span data-stu-id="6c313-243">Wrapping providers</span></span>

<span data-ttu-id="6c313-244">래핑 공급자가 프로 파일링 또는 추적 기능 등의 다른 기능을 사용 하 여 확장을 기존 공급자를 래핑하는 EF 및/또는 ADO.NET 공급자입니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-244">A wrapping provider is an EF and/or ADO.NET provider that wraps an existing provider to extend it with other functionality such as profiling or tracing capabilities.</span></span> <span data-ttu-id="6c313-245">일반적인 방법으로 래핑 공급자를 등록할 수 있습니다 하지만 것이 편리 하 게 공급자 관련 서비스의 해상도 해석 하 여 런타임 시 래핑 공급자를 설치 합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-245">Wrapping providers can be registered in the normal way, but it is often more convenient to setup the wrapping provider at runtime by intercepting the resolution of provider-related services.</span></span> <span data-ttu-id="6c313-246">이렇게 하려면 정적 이벤트 OnLockingConfiguration DbConfiguration 클래스에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-246">The static event OnLockingConfiguration on the DbConfiguration class can be used to do this.</span></span>

<span data-ttu-id="6c313-247">응용 프로그램 도메인에 대 한 모든 EF 구성을 가져올 수는 있는 EF에서 확인 한 이후 이지만 용도로 잠기기 전까지 OnLockingConfiguration 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-247">OnLockingConfiguration is called after EF has determined where all EF configuration for the app domain will be obtained from but before it is locked for use.</span></span> <span data-ttu-id="6c313-248">앱 시작 시 (EF가 사용 됨) 전에 앱 등록 해야이 이벤트에 대 한 이벤트 처리기입니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-248">At app startup (before EF is used) the app should register an event handler for this event.</span></span> <span data-ttu-id="6c313-249">(구성 파일에서이 처리기를 등록 하는 것에 대 한 지원을 추가할 예정 이지만 아직 지원 되지 않습니다.) 이벤트 처리기 다음 ReplaceService 래핑되어야 하는 모든 서비스에 대 한 호출을 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-249">(We are considering adding support for registering this handler in the config file but this is not yet supported.) The event handler should then make a call to ReplaceService for every service that needs to be wrapped.</span></span>  

<span data-ttu-id="6c313-250">예를 들어 IDbConnectionFactory 및 DbProviderService 래핑할이 같은 처리기를 등록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-250">For example, to wrap IDbConnectionFactory and DbProviderService, a handler something like this should be registered:</span></span>

``` csharp
DbConfiguration.OnLockingConfiguration +=
    (_, a) =>
    {
        a.ReplaceService<DbProviderServices>(
            (s, k) => new MyWrappedProviderServices(s));

        a.ReplaceService<IDbConnectionFactory>(
            (s, k) => new MyWrappedConnectionFactory(s));
    };
```

<span data-ttu-id="6c313-251">서비스 해결 되었으면 이제 서비스를 해결 하기 위해 사용 된 키와 함께 래핑되어야 하는 처리기에 전달 됩니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-251">The service that has been resolved and should now be wrapped together with the key that was used to resolve the service are passed to the handler.</span></span> <span data-ttu-id="6c313-252">그런 다음 처리기를이 서비스를 배치 하 고 래핑된 버전을 사용 하 여 반환 되는 서비스를 대체 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-252">The handler can then wrap this service and replace the returned service with the wrapped version.</span></span>

## <a name="resolving-a-dbproviderfactory-with-ef"></a><span data-ttu-id="6c313-253">EF 사용 하 여 DbProviderFactory를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-253">Resolving a DbProviderFactory with EF</span></span>

<span data-ttu-id="6c313-254">DbProviderFactory를 사용 하면 EF에 설명 된 대로 필요한 기본 공급자 형식 중 하나인 합니다 _공급자 형식 개요_ 위의 섹션입니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-254">DbProviderFactory is one of the fundamental provider types needed by EF as described in the _Provider types overview_ section above.</span></span> <span data-ttu-id="6c313-255">이미 언급 했 듯이, 해당 형식이 아닌 EF 및 등록 되지 일반적으로 EF 구성의 일부분 이지만 대신 합니다 machine.config 파일 및/또는 응용 프로그램의 구성 파일에서 일반 ADO.NET 공급자 등록 합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-255">As already mentioned, It is not an EF type and registration is usually not part of EF configuration, but is instead the normal ADO.NET provider registration in the machine.config file and/or application’s config file.</span></span>

<span data-ttu-id="6c313-256">이 EF 불구 하 고 여전히 해당 일반적인 종속성 해결 메커니즘 DbProviderFactory를 찾을 때 사용 하기 위해 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-256">Despite this EF still uses its normal dependency resolution mechanism when looking for a DbProviderFactory to use.</span></span> <span data-ttu-id="6c313-257">기본 해결 프로그램 구성 파일에서는 일반 ADO.NET 등록 하 고 이것이 일반적으로 투명 합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-257">The default resolver uses the normal ADO.NET registration in the config files and so this is usually transparent.</span></span> <span data-ttu-id="6c313-258">일반 종속성 확인으로 인해 메커니즘을 사용 하지만 일반 ADO.NET 등록 수행 하지 않은 경우에 DbProviderFactory를 확인 하는 IDbDependencyResolver를 사용할 수 있도록 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-258">But because of the normal dependency resolution mechanism is used it means that an IDbDependencyResolver can be used to resolve a DbProviderFactory even when normal ADO.NET registration has not been done.</span></span>

<span data-ttu-id="6c313-259">DbProviderFactory를 이러한 방식으로 해결에 몇 가지 의미가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-259">Resolving DbProviderFactory in this way has several implications:</span></span>

*   <span data-ttu-id="6c313-260">코드 기반 구성을 사용 하 여 응용 프로그램에 적절 한 DbProviderFactory를 등록할 해당 DbConfiguration 클래스에서 호출을 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-260">An application using code-based configuration can add calls in their DbConfiguration class to register the appropriate DbProviderFactory.</span></span> <span data-ttu-id="6c313-261">이 기능은 특히 유용 하지 않을 (또는 없나요)는 응용 프로그램에 대 한 확인 전혀 모든 파일 기반 구성을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-261">This is especially useful for applications that do not want to (or cannot) make use of any file-based configuration at all.</span></span>
*   <span data-ttu-id="6c313-262">서비스를 래핑할 수 있습니다 하거나에 설명 된 대로 ReplaceService를 사용 하 여 대체 합니다 _래핑 공급자_ 위의 섹션</span><span class="sxs-lookup"><span data-stu-id="6c313-262">The service can be wrapped or replaced using ReplaceService as described in the _Wrapping providers_ section above</span></span>
*   <span data-ttu-id="6c313-263">이론적으로 DbProviderServices 구현 DbProviderFactory를 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-263">Theoretically, a DbProviderServices implementation could resolve a DbProviderFactory.</span></span>

<span data-ttu-id="6c313-264">이러한 작업 중 하나를 수행 하는 방법에 대 한 주의할 중요 한 점은 EF에서 DbProviderFactory의 조회만 적용 됩니다는 경우</span><span class="sxs-lookup"><span data-stu-id="6c313-264">The important point to note about doing any of these things is that they will only affect the lookup of DbProviderFactory by EF.</span></span> <span data-ttu-id="6c313-265">다른 비 EF 코드는 일반적인 방법으로 등록할 ADO.NET 공급자를 여전히 예상할 수 및 등록이 없는 경우 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-265">Other non-EF code may still expect the ADO.NET provider to be registered in the normal way and may fail if the registration is not found.</span></span> <span data-ttu-id="6c313-266">이 따라서 일반적으로 일반 ADO.NET 방식에서 등록할 DbProviderFactory를 위한 더 나은 것.</span><span class="sxs-lookup"><span data-stu-id="6c313-266">For this reason it is normally better for a DbProviderFactory to be registered in the normal ADO.NET way.</span></span>

### <a name="related-services"></a><span data-ttu-id="6c313-267">관련된 서비스</span><span class="sxs-lookup"><span data-stu-id="6c313-267">Related services</span></span>

<span data-ttu-id="6c313-268">EF는 DbProviderFactory를 해결 하려면 사용 하는 경우 다음이 확인 해야 IProviderInvariantName 및 IDbProviderFactoryResolver 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-268">If EF is used to resolve a DbProviderFactory, then it should also resolve the IProviderInvariantName and IDbProviderFactoryResolver services.</span></span>

<span data-ttu-id="6c313-269">IProviderInvariantName는 DbProviderFactory의 지정된 된 형식에 대 한 공급자 고정 이름을 확인 하는 데 사용 되는 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-269">IProviderInvariantName is a service that is used to determine a provider invariant name for a given type of DbProviderFactory.</span></span> <span data-ttu-id="6c313-270">이 서비스의 기본 구현을 ADO.NET 공급자 등록을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-270">The default implementation of this service uses the ADO.NET provider registration.</span></span> <span data-ttu-id="6c313-271">이 ADO.NET 공급자 DbProviderFactory를 확인 하는 EF에서 때문에 일반적인 방법으로 등록 되지 않은, 경우 다음도 해야이 서비스를 확인할 것을 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-271">This means that if the ADO.NET provider is not registered in the normal way because DbProviderFactory is being resolved by EF, then it will also be necessary to resolve this service.</span></span> <span data-ttu-id="6c313-272">Note DbConfiguration.SetProviderFactory 메서드를 사용 하는 경우이 서비스에 대 한 해결 프로그램을 자동으로 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-272">Note that a resolver for this service is automatically added when using the DbConfiguration.SetProviderFactory method.</span></span>

<span data-ttu-id="6c313-273">에 설명 된 대로 합니다 _공급자 형식 개요_ 위의 섹션에서 IDbProviderFactoryResolver 지정된 DbConnection 개체에서 올바른 DbProviderFactory를 가져오는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-273">As described in the _Provider types overview_ section above, the IDbProviderFactoryResolver is used to obtain the correct DbProviderFactory from a given DbConnection object.</span></span> <span data-ttu-id="6c313-274">.NET 4에서 실행 되는 ADO.NET 공급자 등록을 사용 하는 경우이 서비스의 기본 구현입니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-274">The default implementation of this service when running on .NET 4 uses the ADO.NET provider registration.</span></span> <span data-ttu-id="6c313-275">이 ADO.NET 공급자 DbProviderFactory를 확인 하는 EF에서 때문에 일반적인 방법으로 등록 되지 않은, 경우 다음도 해야이 서비스를 확인할 것을 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="6c313-275">This means that if the ADO.NET provider is not registered in the normal way because DbProviderFactory is being resolved by EF, then it will also be necessary to resolve this service.</span></span>
