---
title: 자동 추적 엔터티 - EF6
author: divega
ms.date: 2016-10-23
ms.assetid: 5e60f5be-7bbb-4bf8-835e-0ac808d6c84a
ms.openlocfilehash: bd22df9e14fe71ae065baf1d747b1642dd7bafce
ms.sourcegitcommit: 0d36e8ff0892b7f034b765b15e041f375f88579a
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/09/2018
ms.locfileid: "44250869"
---
# <a name="self-tracking-entities"></a><span data-ttu-id="30912-102">자동 추적 엔터티</span><span class="sxs-lookup"><span data-stu-id="30912-102">Self-tracking entities</span></span>

> [!IMPORTANT]
> <span data-ttu-id="30912-103">자동 추적 엔터티 템플릿을 더 이상 권장하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="30912-103">We no longer recommend using the self-tracking-entities template.</span></span> <span data-ttu-id="30912-104">이 템플릿은 기존 응용 프로그램을 지원하는 용도로만 제공될 것입니다.</span><span class="sxs-lookup"><span data-stu-id="30912-104">It will only continue to be available to support existing applications.</span></span> <span data-ttu-id="30912-105">응용 프로그램에서 연결이 끊긴 엔터티 그래프를 사용해야 하는 경우 커뮤니티에서 적극적으로 개발한 자동 추적 엔터티와 비슷한 기술인 [추적 가능 엔터티](http://trackableentities.github.io/) 같은 다른 대안을 고려하거나 하위 수준 변경 내용 추적 API를 사용하여 사용자 지정 코드를 작성하는 방법을 고려해 보세요.</span><span class="sxs-lookup"><span data-stu-id="30912-105">If your application requires working with disconnected graphs of entities, consider other alternatives such as [Trackable Entities](http://trackableentities.github.io/), which is a technology similar to Self-Tracking-Entities that is more actively developed by the community, or writing custom code using the low-level change tracking APIs.</span></span>

<span data-ttu-id="30912-106">Entity Framework 기반 응용 프로그램에서 컨텍스트는 개체의 변경 내용을 추적합니다.</span><span class="sxs-lookup"><span data-stu-id="30912-106">In an Entity Framework-based application, a context is responsible for tracking changes in your objects.</span></span> <span data-ttu-id="30912-107">그러면 관리자는 SaveChanges 메서드를 사용하여 변경 내용을 데이터베이스에 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="30912-107">You then use the SaveChanges method to persist the changes to the database.</span></span> <span data-ttu-id="30912-108">N 계층 응용 프로그램을 작업할 때 엔터티 개체는 일반적으로 컨텍스트와 연결이 끊어지므로 변경 내용을 추적하고 변경 내용을 컨텍스트에 보고하는 방법을 결정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="30912-108">When working with N-Tier applications, the entity objects are usually disconnected from the context and you must decide how to track changes and report those changes back to the context.</span></span> <span data-ttu-id="30912-109">STE(자동 추적 엔터티)는 모든 계층의 변경 내용을 추적한 후 저장하기 위해 컨텍스트에 재생합니다.</span><span class="sxs-lookup"><span data-stu-id="30912-109">Self-Tracking Entities (STEs) can help you track changes in any tier and then replay these changes into a context to be saved.</span></span>  

<span data-ttu-id="30912-110">개체 그래프가 변경된 계층에서 컨텍스트를 사용할 수 없는 경우에만 STE를 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="30912-110">Use STEs only if the context is not available on a tier where the changes to the object graph are made.</span></span> <span data-ttu-id="30912-111">컨텍스트를 사용할 수 있는 경우 컨텍스트가 변경 내용 추적을 알아서 처리하므로 STE를 사용할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="30912-111">If the context is available, there is no need to use STEs because the context will take care of tracking changes.</span></span>  

<span data-ttu-id="30912-112">이 템플릿 항목은 두 개의 .tt(텍스트 템플릿) 파일을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="30912-112">This template item generates two .tt (text template) files:</span></span>  

- <span data-ttu-id="30912-113">**\<model name\>.tt** 파일은 자동 추적 엔터티에서 상태를 설정할 수 있도록 하는 확장 메서드와 자동 추적 엔터티에 의해 사용되는 변경 내용 추적 논리가 포함된 도우미 클래스 및 엔터티 형식을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="30912-113">The **\<model name\>.tt** file generates the entity types and a helper class that contains the change-tracking logic that is used by self-tracking entities and the extension methods that allow setting state on self-tracking entities.</span></span>  
- <span data-ttu-id="30912-114">**\<model name\>.Context.tt** 파일은 파생된 컨텍스트 그리고 **ObjectContext** 및 **ObjectSet** 클래스에 대한 **ApplyChanges** 메서드를 포함하는 확장 클래스를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="30912-114">The **\<model name\>.Context.tt** file generates a derived context and an extension class that contains **ApplyChanges** methods for the **ObjectContext** and **ObjectSet** classes.</span></span> <span data-ttu-id="30912-115">이러한 메서드는 자동 추적 엔터티의 그래프에 포함된 변경 내용 추적 정보를 검사하여 데이터베이스에 변경 내용을 저장하기 위해 수행해야 하는 작업 집합을 유추합니다.</span><span class="sxs-lookup"><span data-stu-id="30912-115">These methods examine the change-tracking information that is contained in the graph of self-tracking entities to infer the set of operations that must be performed to save the changes in the database.</span></span>  

## <a name="get-started"></a><span data-ttu-id="30912-116">시작</span><span class="sxs-lookup"><span data-stu-id="30912-116">Get Started</span></span>  

<span data-ttu-id="30912-117">시작하려면 [자동 추적 엔터티 연습](walkthrough.md) 페이지를 방문하세요.</span><span class="sxs-lookup"><span data-stu-id="30912-117">To get started, visit the [Self-Tracking Entities Walkthrough](walkthrough.md) page.</span></span>  

## <a name="functional-considerations-when-working-with-self-tracking-entities"></a><span data-ttu-id="30912-118">자동 추적 엔터티로 작업하는 경우의 기능 고려 사항</span><span class="sxs-lookup"><span data-stu-id="30912-118">Functional Considerations When Working with Self-Tracking Entities</span></span>  
> [!IMPORTANT]
> <span data-ttu-id="30912-119">자동 추적 엔터티 템플릿을 더 이상 권장하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="30912-119">We no longer recommend using the self-tracking-entities template.</span></span> <span data-ttu-id="30912-120">이 템플릿은 기존 응용 프로그램을 지원하는 용도로만 제공될 것입니다.</span><span class="sxs-lookup"><span data-stu-id="30912-120">It will only continue to be available to support existing applications.</span></span> <span data-ttu-id="30912-121">응용 프로그램에서 연결이 끊긴 엔터티 그래프를 사용해야 하는 경우 커뮤니티에서 적극적으로 개발한 자동 추적 엔터티와 비슷한 기술인 [추적 가능 엔터티](http://trackableentities.github.io/) 같은 다른 대안을 고려하거나 하위 수준 변경 내용 추적 API를 사용하여 사용자 지정 코드를 작성하는 방법을 고려해 보세요.</span><span class="sxs-lookup"><span data-stu-id="30912-121">If your application requires working with disconnected graphs of entities, consider other alternatives such as [Trackable Entities](http://trackableentities.github.io/), which is a technology similar to Self-Tracking-Entities that is more actively developed by the community, or writing custom code using the low-level change tracking APIs.</span></span>

<span data-ttu-id="30912-122">자동 추적 엔터티로 작업하는 경우 고려할 사항은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="30912-122">Consider the following when working with self-tracking entities:</span></span>  

- <span data-ttu-id="30912-123">클라이언트 프로젝트에 엔터티 형식을 포함하는 어셈블리에 대한 참조가 있는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="30912-123">Make sure that your client project has a reference to the assembly containing the entity types.</span></span> <span data-ttu-id="30912-124">클라이언트 프로젝트에 서비스 참조만 추가하는 경우 클라이언트 프로젝트는 실제 자동 추적 엔터티 형식이 아니라 WCF 프록시 형식을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="30912-124">If you add only the service reference to the client project, the client project will use the WCF proxy types and not the actual self-tracking entity types.</span></span> <span data-ttu-id="30912-125">즉, 클라이언트의 엔터티 추적을 관리하는 자동화된 알림 기능을 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="30912-125">This means that you will not get the automated notification features that manage the tracking of the entities on the client.</span></span> <span data-ttu-id="30912-126">의도적으로 엔터티 형식을 포함하지 않으려는 경우 변경 내용을 다시 서비스에 보내기 위해 클라이언트에서 수동으로 변경 추적 정보를 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="30912-126">If you intentionally do not want to include the entity types, you will have to manually set change-tracking information on the client for the changes to be sent back to the service.</span></span>  
- <span data-ttu-id="30912-127">서비스 작업 호출은 상태 비저장이어야 하며 개체 컨텍스트의 새 인스턴스를 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="30912-127">Calls to the service operation should be stateless and create a new instance of object context.</span></span> <span data-ttu-id="30912-128">또한 **using** 블록에서 개체 컨텍스트를 만드는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="30912-128">We also recommend that you create object context in a **using** block.</span></span>  
- <span data-ttu-id="30912-129">클라이언트에서 수정된 그래프를 서비스에 보낸 다음, 클라이언트에서 동일한 그래프로 계속 작업하려는 경우 그래프를 수동으로 반복하고 각 개체에서 **AcceptChanges** 메서드를 호출하여 변경 내용 추적기를 다시 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="30912-129">When you send the graph that was modified on the client to the service and then intend to continue working with the same graph on the client, you have to manually iterate through the graph and call the **AcceptChanges** method on each object to reset the change tracker.</span></span>  

    > <span data-ttu-id="30912-130">그래프의 개체에 속성과 데이터베이스에서 생성된 값(예: ID 또는 동시성 값)이 포함되어 있는 경우 Entity Framework는 이러한 속성 값을 **SaveChanges** 메서드가 호출된 후 데이터베이스에서 생성한 값으로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="30912-130">If objects in your graph contain properties with database-generated values (for example, identity or concurrency values), Entity Framework will replace values of these properties with the database-generated values after the **SaveChanges** method is called.</span></span> <span data-ttu-id="30912-131">저장된 개체나 개체에 대해 생성된 속성 값 목록을 클라이언트에 다시 반환하기 위해 서비스 작업을 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30912-131">You can implement your service operation to return saved objects or a list of generated property values for the objects back to the client.</span></span> <span data-ttu-id="30912-132">그러면 클라이언트가 개체 인스턴스나 개체 속성 값을 개체 또는 서비스 작업에서 반환된 속성 값으로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="30912-132">The client would then need to replace the object instances or object property values with the objects or property values returned from the service operation.</span></span>  
- <span data-ttu-id="30912-133">여러 서비스 요청의 그래프를 병합하면 결과로 생성된 그래프에 중복 키 값을 가진 개체가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30912-133">Merging graphs from multiple service requests may introduce objects with duplicate key values in the resulting graph.</span></span> <span data-ttu-id="30912-134">Entity Framework는 **ApplyChanges** 메서드를 호출할 때 중복 키를 가진 개체를 제거하지 않고 대신 예외를 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="30912-134">Entity Framework does not remove the objects with duplicate keys when you call the **ApplyChanges** method but instead throws an exception.</span></span> <span data-ttu-id="30912-135">그래프에 중복 키 값이 없도록 하려면 [자동 추적 엔터티: ApplyChanges 및 중복 엔터티](http://go.microsoft.com/fwlink/?LinkID=205119&clcid=0x409) 블로그에 설명된 패턴 중 하나를 따르십시오.</span><span class="sxs-lookup"><span data-stu-id="30912-135">To avoid having graphs with duplicate key values follow one of the patterns described in the following blog: [Self-Tracking Entities: ApplyChanges and duplicate entities](http://go.microsoft.com/fwlink/?LinkID=205119&clcid=0x409).</span></span>  
- <span data-ttu-id="30912-136">외래 키 속성을 설정하여 개체 간의 관계를 변경하는 경우 참조 탐색 속성이 null로 설정되고 클라이언트에서 해당하는 주 엔터티에 동기화되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="30912-136">When you change the relationship between objects by setting the foreign key property, the reference navigation property is set to null and not synchronized to the appropriate principal entity on the client.</span></span> <span data-ttu-id="30912-137">그래프가 개체 컨텍스트에 연결된 후(예를 들어, **ApplyChanges** 메서드를 호출한 후) 외래 키 속성과 탐색 속성이 동기화됩니다.</span><span class="sxs-lookup"><span data-stu-id="30912-137">After the graph is attached to the object context (for example, after you call the **ApplyChanges** method), the foreign key properties and navigation properties are synchronized.</span></span>  

    > <span data-ttu-id="30912-138">참조 탐색 속성을 해당하는 주 개체와 동기화하지 않으면 외래 키 관계에서 하위 삭제를 지정한 경우 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30912-138">Not having a reference navigation property synchronized with the appropriate principal object could be an issue if you have specified cascade delete on the foreign key relationship.</span></span> <span data-ttu-id="30912-139">주체를 삭제해도 종속 개체에 삭제가 전파되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="30912-139">If you delete the principal, the delete will not be propagated to the dependent objects.</span></span> <span data-ttu-id="30912-140">하위 삭제를 지정한 경우 외래 키 속성을 설정하는 대신 탐색 속성을 사용하여 관계를 변경합니다.</span><span class="sxs-lookup"><span data-stu-id="30912-140">If you have cascade deletes specified, use navigation properties to change relationships instead of setting the foreign key property.</span></span>  
- <span data-ttu-id="30912-141">자동 추적 엔터티는 지연 로드를 수행할 수 있도록 설정되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="30912-141">Self-tracking entities are not enabled to perform lazy loading.</span></span>  
- <span data-ttu-id="30912-142">ASP.NET 상태 관리 개체로의 이진 serialization 및 serialization은 자동 추적 엔터티에서 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="30912-142">Binary serialization and serialization to ASP.NET state management objects is not supported by self-tracking entities.</span></span> <span data-ttu-id="30912-143">하지만 템플릿을 사용자 지정하여 이진 serialization 지원을 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30912-143">However, you can customize the template to add the binary serialization support.</span></span> <span data-ttu-id="30912-144">자세한 내용은 [자동 추적 엔터티에서 이진 serialization 및 ViewState 사용](http://go.microsoft.com/fwlink/?LinkId=199208)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="30912-144">For more information, see [Using Binary Serialization and ViewState with Self-Tracking Entities](http://go.microsoft.com/fwlink/?LinkId=199208).</span></span>  

## <a name="security-considerations"></a><span data-ttu-id="30912-145">보안 고려 사항</span><span class="sxs-lookup"><span data-stu-id="30912-145">Security Considerations</span></span>  

<span data-ttu-id="30912-146">자동 추적 엔터티를 사용할 때 다음과 같은 보안 사항을 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="30912-146">The following security considerations should be taken into account when working with self-tracking entities:</span></span>  

- <span data-ttu-id="30912-147">서비스에서는 신뢰할 수 없는 채널을 통해서나 신뢰할 수 없는 클라이언트에서 데이터를 검색하거나 업데이트하는 요청을 신뢰해서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="30912-147">A service should not trust requests to retrieve or update data from a non-trusted client or through a non-trusted channel.</span></span> <span data-ttu-id="30912-148">클라이언트를 인증해야 하며, 보안 채널이나 메시지 봉투를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="30912-148">A client must be authenticated: a secure channel or message envelope should be used.</span></span> <span data-ttu-id="30912-149">클라이언트의 데이터 업데이트 또는 검색 요청은 지정된 시나리오에서 예상되는 정당한 변경을 따르는지 확인하기 위해 유효성이 검사되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="30912-149">Clients' requests to update or retrieve data must be validated to ensure they conform to expected and legitimate changes for the given scenario.</span></span>  
- <span data-ttu-id="30912-150">엔터티 키로 중요한 정보(예: 주민 등록 번호)를 사용하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="30912-150">Avoid using sensitive information as entity keys (for example, social security numbers).</span></span> <span data-ttu-id="30912-151">이는 자동 추적 엔터티 그래프의 중요한 정보를 완전히 신뢰할 수 없는 클라이언트로 잘못 serialize하는 가능성을 줄이기 위해서입니다.</span><span class="sxs-lookup"><span data-stu-id="30912-151">This mitigates the possibility of inadvertently serializing sensitive information in the self-tracking entity graphs to a client that is not fully trusted.</span></span> <span data-ttu-id="30912-152">독립 연결을 사용하는 경우 serialize될 항목과 관련된 엔터티의 원래 키가 클라이언트로 전송될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30912-152">With independent associations, the original key of an entity that is related to the one that is being serialized might be sent to the client as well.</span></span>  
- <span data-ttu-id="30912-153">중요한 데이터가 포함된 예외 메시지를 클라이언트 계층에 전파하지 않으려면 서버 계층에 대한 **ApplyChanges** 및 **SaveChanges** 호출이 예외 처리 코드에 래핑되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="30912-153">To avoid propagating exception messages that contain sensitive data to the client tier, calls to **ApplyChanges** and **SaveChanges** on the server tier should be wrapped in exception-handling code.</span></span>  
