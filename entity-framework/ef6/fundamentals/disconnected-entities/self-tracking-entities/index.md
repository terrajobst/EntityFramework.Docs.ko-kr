---
title: 자동 추적 엔터티 - EF6
author: divega
ms.date: 10/23/2016
ms.assetid: 5e60f5be-7bbb-4bf8-835e-0ac808d6c84a
ms.openlocfilehash: 3575977ceabe7d93ac48d5fac253eac1341e2353
ms.sourcegitcommit: 2b787009fd5be5627f1189ee396e708cd130e07b
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/13/2018
ms.locfileid: "45489702"
---
# <a name="self-tracking-entities"></a>자동 추적 엔터티

> [!IMPORTANT]
> 자동 추적 엔터티 템플릿을 더 이상 권장하지 않습니다. 이 템플릿은 기존 응용 프로그램을 지원하는 용도로만 제공될 것입니다. 응용 프로그램에서 연결이 끊긴 엔터티 그래프를 사용해야 하는 경우 커뮤니티에서 적극적으로 개발한 자동 추적 엔터티와 비슷한 기술인 [추적 가능 엔터티](http://trackableentities.github.io/) 같은 다른 대안을 고려하거나 하위 수준 변경 내용 추적 API를 사용하여 사용자 지정 코드를 작성하는 방법을 고려해 보세요.

Entity Framework 기반 응용 프로그램에서 컨텍스트는 개체의 변경 내용을 추적합니다. 그러면 관리자는 SaveChanges 메서드를 사용하여 변경 내용을 데이터베이스에 유지합니다. N 계층 응용 프로그램을 작업할 때 엔터티 개체는 일반적으로 컨텍스트와 연결이 끊어지므로 변경 내용을 추적하고 변경 내용을 컨텍스트에 보고하는 방법을 결정해야 합니다. STE(자동 추적 엔터티)는 모든 계층의 변경 내용을 추적한 후 저장하기 위해 컨텍스트에 재생합니다.  

개체 그래프가 변경된 계층에서 컨텍스트를 사용할 수 없는 경우에만 STE를 사용하세요. 컨텍스트를 사용할 수 있는 경우 컨텍스트가 변경 내용 추적을 알아서 처리하므로 STE를 사용할 필요가 없습니다.  

이 템플릿 항목은 두 개의 .tt(텍스트 템플릿) 파일을 생성합니다.  

- **\<model name\>.tt** 파일은 자동 추적 엔터티에서 상태를 설정할 수 있도록 하는 확장 메서드와 자동 추적 엔터티에 의해 사용되는 변경 내용 추적 논리가 포함된 도우미 클래스 및 엔터티 형식을 생성합니다.  
- **\<model name\>.Context.tt** 파일은 파생된 컨텍스트 그리고 **ObjectContext** 및 **ObjectSet** 클래스에 대한 **ApplyChanges** 메서드를 포함하는 확장 클래스를 생성합니다. 이러한 메서드는 자동 추적 엔터티의 그래프에 포함된 변경 내용 추적 정보를 검사하여 데이터베이스에 변경 내용을 저장하기 위해 수행해야 하는 작업 집합을 유추합니다.  

## <a name="get-started"></a>시작  

시작하려면 [자동 추적 엔터티 연습](walkthrough.md) 페이지를 방문하세요.  

## <a name="functional-considerations-when-working-with-self-tracking-entities"></a>자동 추적 엔터티로 작업하는 경우의 기능 고려 사항  
> [!IMPORTANT]
> 자동 추적 엔터티 템플릿을 더 이상 권장하지 않습니다. 이 템플릿은 기존 응용 프로그램을 지원하는 용도로만 제공될 것입니다. 응용 프로그램에서 연결이 끊긴 엔터티 그래프를 사용해야 하는 경우 커뮤니티에서 적극적으로 개발한 자동 추적 엔터티와 비슷한 기술인 [추적 가능 엔터티](http://trackableentities.github.io/) 같은 다른 대안을 고려하거나 하위 수준 변경 내용 추적 API를 사용하여 사용자 지정 코드를 작성하는 방법을 고려해 보세요.

자동 추적 엔터티로 작업하는 경우 고려할 사항은 다음과 같습니다.  

- 클라이언트 프로젝트에 엔터티 형식을 포함하는 어셈블리에 대한 참조가 있는지 확인합니다. 클라이언트 프로젝트에 서비스 참조만 추가하는 경우 클라이언트 프로젝트는 실제 자동 추적 엔터티 형식이 아니라 WCF 프록시 형식을 사용합니다. 즉, 클라이언트의 엔터티 추적을 관리하는 자동화된 알림 기능을 사용할 수 없습니다. 의도적으로 엔터티 형식을 포함하지 않으려는 경우 변경 내용을 다시 서비스에 보내기 위해 클라이언트에서 수동으로 변경 추적 정보를 설정해야 합니다.  
- 서비스 작업 호출은 상태 비저장이어야 하며 개체 컨텍스트의 새 인스턴스를 만들어야 합니다. 또한 **using** 블록에서 개체 컨텍스트를 만드는 것이 좋습니다.  
- 클라이언트에서 수정된 그래프를 서비스에 보낸 다음, 클라이언트에서 동일한 그래프로 계속 작업하려는 경우 그래프를 수동으로 반복하고 각 개체에서 **AcceptChanges** 메서드를 호출하여 변경 내용 추적기를 다시 설정해야 합니다.  

    > 그래프의 개체에 속성과 데이터베이스에서 생성된 값(예: ID 또는 동시성 값)이 포함되어 있는 경우 Entity Framework는 이러한 속성 값을 **SaveChanges** 메서드가 호출된 후 데이터베이스에서 생성한 값으로 바꿉니다. 저장된 개체나 개체에 대해 생성된 속성 값 목록을 클라이언트에 다시 반환하기 위해 서비스 작업을 구현할 수 있습니다. 그러면 클라이언트가 개체 인스턴스나 개체 속성 값을 개체 또는 서비스 작업에서 반환된 속성 값으로 바꿉니다.  
- 여러 서비스 요청의 그래프를 병합하면 결과로 생성된 그래프에 중복 키 값을 가진 개체가 발생할 수 있습니다. Entity Framework는 **ApplyChanges** 메서드를 호출할 때 중복 키를 가진 개체를 제거하지 않고 대신 예외를 throw합니다. 그래프에 중복 키 값이 없도록 하려면 [자동 추적 엔터티: ApplyChanges 및 중복 엔터티](http://go.microsoft.com/fwlink/?LinkID=205119&clcid=0x409) 블로그에 설명된 패턴 중 하나를 따르십시오.  
- 외래 키 속성을 설정하여 개체 간의 관계를 변경하는 경우 참조 탐색 속성이 null로 설정되고 클라이언트에서 해당하는 주 엔터티에 동기화되지 않습니다. 그래프가 개체 컨텍스트에 연결된 후(예를 들어, **ApplyChanges** 메서드를 호출한 후) 외래 키 속성과 탐색 속성이 동기화됩니다.  

    > 참조 탐색 속성을 해당하는 주 개체와 동기화하지 않으면 외래 키 관계에서 하위 삭제를 지정한 경우 문제가 발생할 수 있습니다. 주체를 삭제해도 종속 개체에 삭제가 전파되지 않습니다. 하위 삭제를 지정한 경우 외래 키 속성을 설정하는 대신 탐색 속성을 사용하여 관계를 변경합니다.  
- 자동 추적 엔터티는 지연 로드를 수행할 수 있도록 설정되지 않습니다.  
- ASP.NET 상태 관리 개체로의 이진 serialization 및 serialization은 자동 추적 엔터티에서 지원되지 않습니다. 하지만 템플릿을 사용자 지정하여 이진 serialization 지원을 추가할 수 있습니다. 자세한 내용은 [자동 추적 엔터티에서 이진 serialization 및 ViewState 사용](http://go.microsoft.com/fwlink/?LinkId=199208)을 참조하세요.  

## <a name="security-considerations"></a>보안 고려 사항  

자동 추적 엔터티를 사용할 때 다음과 같은 보안 사항을 고려해야 합니다.  

- 서비스에서는 신뢰할 수 없는 채널을 통해서나 신뢰할 수 없는 클라이언트에서 데이터를 검색하거나 업데이트하는 요청을 신뢰해서는 안 됩니다. 클라이언트를 인증해야 하며, 보안 채널이나 메시지 봉투를 사용해야 합니다. 클라이언트의 데이터 업데이트 또는 검색 요청은 지정된 시나리오에서 예상되는 정당한 변경을 따르는지 확인하기 위해 유효성이 검사되어야 합니다.  
- 엔터티 키로 중요한 정보(예: 주민 등록 번호)를 사용하지 마십시오. 이는 자동 추적 엔터티 그래프의 중요한 정보를 완전히 신뢰할 수 없는 클라이언트로 잘못 serialize하는 가능성을 줄이기 위해서입니다. 독립 연결을 사용하는 경우 serialize될 항목과 관련된 엔터티의 원래 키가 클라이언트로 전송될 수도 있습니다.  
- 중요한 데이터가 포함된 예외 메시지를 클라이언트 계층에 전파하지 않으려면 서버 계층에 대한 **ApplyChanges** 및 **SaveChanges** 호출이 예외 처리 코드에 래핑되어야 합니다.  
