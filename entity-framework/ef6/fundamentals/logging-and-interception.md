---
title: 데이터베이스 작업 로깅 및 가로채기-EF6
author: divega
ms.date: 10/23/2016
ms.assetid: b5ee7eb1-88cc-456e-b53c-c67e24c3f8ca
ms.openlocfilehash: 35b0284a5ad8b2b732f074589bd458d243312575
ms.sourcegitcommit: 708b18520321c587b2046ad2ea9fa7c48aeebfe5
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/09/2019
ms.locfileid: "72181667"
---
# <a name="logging-and-intercepting-database-operations"></a><span data-ttu-id="616a8-102">데이터베이스 작업 로깅 및 가로채기</span><span class="sxs-lookup"><span data-stu-id="616a8-102">Logging and intercepting database operations</span></span>
> [!NOTE]
> <span data-ttu-id="616a8-103">**EF6 이상만** - 이 페이지에서 다루는 기능, API 등은 Entity Framework 6에 도입되었습니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-103">**EF6 Onwards Only** - The features, APIs, etc. discussed in this page were introduced in Entity Framework 6.</span></span> <span data-ttu-id="616a8-104">이전 버전을 사용하는 경우 이 정보의 일부 또는 전체가 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-104">If you are using an earlier version, some or all of the information does not apply.</span></span>  

<span data-ttu-id="616a8-105">Entity Framework 6부터 데이터베이스에 명령을 보낼 Entity Framework 언제 든 지이 명령은 응용 프로그램 코드에 의해 가로챌 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-105">Starting with Entity Framework 6, anytime Entity Framework sends a command to the database this command can be intercepted by application code.</span></span> <span data-ttu-id="616a8-106">이는 SQL 로깅을 위해 가장 일반적으로 사용 되지만 명령을 수정 하거나 중단 하는 데 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-106">This is most commonly used for logging SQL, but can also be used to modify or abort the command.</span></span>  

<span data-ttu-id="616a8-107">구체적으로 말하면 EF에는 다음이 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-107">Specifically, EF includes:</span></span>  

- <span data-ttu-id="616a8-108">DataContext 로그인과 유사한 컨텍스트의 로그 속성 LINQ to SQL</span><span class="sxs-lookup"><span data-stu-id="616a8-108">A Log property for the context similar to DataContext.Log in LINQ to SQL</span></span>  
- <span data-ttu-id="616a8-109">로그로 전송 되는 출력의 내용 및 형식을 사용자 지정 하는 메커니즘</span><span class="sxs-lookup"><span data-stu-id="616a8-109">A mechanism to customize the content and formatting of the output sent to the log</span></span>  
- <span data-ttu-id="616a8-110">제어/유연성을 제공 하는 가로채기의 하위 수준 구성 요소</span><span class="sxs-lookup"><span data-stu-id="616a8-110">Low-level building blocks for interception giving greater control/flexibility</span></span>  

## <a name="context-log-property"></a><span data-ttu-id="616a8-111">컨텍스트 로그 속성</span><span class="sxs-lookup"><span data-stu-id="616a8-111">Context Log property</span></span>  

<span data-ttu-id="616a8-112">DbContext 속성은 문자열을 사용 하는 모든 메서드에 대 한 대리자로 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-112">The DbContext.Database.Log property can be set to a delegate for any method that takes a string.</span></span> <span data-ttu-id="616a8-113">가장 일반적으로 사용 되는 모든 TextWriter는 해당 TextWriter의 "Write" 메서드로 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-113">Most commonly it is used with any TextWriter by setting it to the “Write” method of that TextWriter.</span></span> <span data-ttu-id="616a8-114">현재 컨텍스트에서 생성 된 모든 SQL은 해당 기록기에 로깅됩니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-114">All SQL generated by the current context will be logged to that writer.</span></span> <span data-ttu-id="616a8-115">예를 들어 다음 코드는 콘솔에 SQL을 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-115">For example, the following code will log SQL to the console:</span></span>  

``` csharp
using (var context = new BlogContext())
{
    context.Database.Log = Console.Write;

    // Your code here...
}
```  

<span data-ttu-id="616a8-116">컨텍스트를 확인 합니다. .Log가 Console. Write로 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-116">Notice that context.Database.Log is set to Console.Write.</span></span> <span data-ttu-id="616a8-117">이는 콘솔에 SQL을 기록 하는 데 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-117">This is all that is needed to log SQL to the console.</span></span>  

<span data-ttu-id="616a8-118">약간의 출력을 볼 수 있도록 몇 가지 간단한 쿼리/삽입/업데이트 코드를 추가 해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-118">Let’s add some simple query/insert/update code so that we can see some output:</span></span>  

``` csharp
using (var context = new BlogContext())
{
    context.Database.Log = Console.Write;

    var blog = context.Blogs.First(b => b.Title == "One Unicorn");

    blog.Posts.First().Title = "Green Eggs and Ham";

    blog.Posts.Add(new Post { Title = "I do not like them!" });

    context.SaveChangesAsync().Wait();
}
```  

<span data-ttu-id="616a8-119">그러면 다음과 같은 출력이 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-119">This will generate the following output:</span></span>  

``` SQL
SELECT TOP (1)
    [Extent1].[Id] AS [Id],
    [Extent1].[Title] AS [Title]
    FROM [dbo].[Blogs] AS [Extent1]
    WHERE (N'One Unicorn' = [Extent1].[Title]) AND ([Extent1].[Title] IS NOT NULL)
-- Executing at 10/8/2013 10:55:41 AM -07:00
-- Completed in 4 ms with result: SqlDataReader

SELECT
    [Extent1].[Id] AS [Id],
    [Extent1].[Title] AS [Title],
    [Extent1].[BlogId] AS [BlogId]
    FROM [dbo].[Posts] AS [Extent1]
    WHERE [Extent1].[BlogId] = @EntityKeyValue1
-- EntityKeyValue1: '1' (Type = Int32)
-- Executing at 10/8/2013 10:55:41 AM -07:00
-- Completed in 2 ms with result: SqlDataReader

UPDATE [dbo].[Posts]
SET [Title] = @0
WHERE ([Id] = @1)
-- @0: 'Green Eggs and Ham' (Type = String, Size = -1)
-- @1: '1' (Type = Int32)
-- Executing asynchronously at 10/8/2013 10:55:41 AM -07:00
-- Completed in 12 ms with result: 1

INSERT [dbo].[Posts]([Title], [BlogId])
VALUES (@0, @1)
SELECT [Id]
FROM [dbo].[Posts]
WHERE @@ROWCOUNT > 0 AND [Id] = scope_identity()
-- @0: 'I do not like them!' (Type = String, Size = -1)
-- @1: '1' (Type = Int32)
-- Executing asynchronously at 10/8/2013 10:55:41 AM -07:00
-- Completed in 2 ms with result: SqlDataReader
```  

<span data-ttu-id="616a8-120">이는 데이터베이스 초기화가 이미 발생 한 경우의 출력입니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-120">(Note that this is the output assuming any database initialization has already happened.</span></span> <span data-ttu-id="616a8-121">데이터베이스 초기화가 아직 발생 하지 않은 경우에는 새 데이터베이스를 확인 하거나 만들 때 모든 작업에서 마이그레이션을 수행 하는 것을 보여 주는 훨씬 더 많은 출력이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-121">If database initialization had not already happened then there would be a lot more output showing all the work Migrations does under the covers to check for or create a new database.)</span></span>  

## <a name="what-gets-logged"></a><span data-ttu-id="616a8-122">기록 되는 항목</span><span class="sxs-lookup"><span data-stu-id="616a8-122">What gets logged?</span></span>  

<span data-ttu-id="616a8-123">Log 속성이 설정 되 면 다음 내용이 모두 로깅됩니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-123">When the Log property is set all of the following will be logged:</span></span>  

- <span data-ttu-id="616a8-124">모든 유형의 명령에 대 한 SQL</span><span class="sxs-lookup"><span data-stu-id="616a8-124">SQL for all different kinds of commands.</span></span> <span data-ttu-id="616a8-125">예를 들면 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-125">For example:</span></span>  
    - <span data-ttu-id="616a8-126">일반 LINQ 쿼리, eSQL 쿼리 및 SqlQuery와 같은 메서드의 원시 쿼리를 포함 하는 쿼리</span><span class="sxs-lookup"><span data-stu-id="616a8-126">Queries, including normal LINQ queries, eSQL queries, and raw queries from methods such as SqlQuery</span></span>  
    - <span data-ttu-id="616a8-127">SaveChanges의 일부로 생성 된 삽입, 업데이트 및 삭제</span><span class="sxs-lookup"><span data-stu-id="616a8-127">Inserts, updates, and deletes generated as part of SaveChanges</span></span>  
    - <span data-ttu-id="616a8-128">지연 로드에 의해 생성 된 것과 같은 관계 로딩 쿼리</span><span class="sxs-lookup"><span data-stu-id="616a8-128">Relationship loading queries such as those generated by lazy loading</span></span>  
- <span data-ttu-id="616a8-129">매개 변수</span><span class="sxs-lookup"><span data-stu-id="616a8-129">Parameters</span></span>  
- <span data-ttu-id="616a8-130">명령이 비동기적으로 실행 되 고 있는지 여부</span><span class="sxs-lookup"><span data-stu-id="616a8-130">Whether or not the command is being executed asynchronously</span></span>  
- <span data-ttu-id="616a8-131">명령의 실행이 시작 된 시간을 나타내는 타임 스탬프입니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-131">A timestamp indicating when the command started executing</span></span>  
- <span data-ttu-id="616a8-132">명령이 성공적으로 완료 되었는지, 예외를 throw 하 여 실패 했는지, 비동기의 경우가 취소 되었는지 여부</span><span class="sxs-lookup"><span data-stu-id="616a8-132">Whether or not the command completed successfully, failed by throwing an exception, or, for async, was canceled</span></span>  
- <span data-ttu-id="616a8-133">결과 값의 일부 표시</span><span class="sxs-lookup"><span data-stu-id="616a8-133">Some indication of the result value</span></span>  
- <span data-ttu-id="616a8-134">명령을 실행 하는 데 걸린 대략적인 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-134">The approximate amount of time it took to execute the command.</span></span> <span data-ttu-id="616a8-135">이는 명령을 전송 하 여 결과 개체를 다시 가져오는 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-135">Note that this is the time from sending the command to getting the result object back.</span></span> <span data-ttu-id="616a8-136">결과를 읽을 시간은 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-136">It does not include time to read the results.</span></span>  

<span data-ttu-id="616a8-137">위의 예제 출력을 살펴보면 로깅되는 네 개의 명령 각각은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-137">Looking at the example output above, each of the four commands logged are:</span></span>  

- <span data-ttu-id="616a8-138">컨텍스트 호출로 인해 발생 하는 쿼리입니다. 블로그. 첫 번째</span><span class="sxs-lookup"><span data-stu-id="616a8-138">The query resulting from the call to context.Blogs.First</span></span>  
    - <span data-ttu-id="616a8-139">"First"는 ToString을 호출할 수 있는 IQueryable을 제공 하지 않으므로 SQL을 가져오는 ToString 메서드가이 쿼리에 대해 작동 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-139">Notice that the ToString method of getting the SQL would not have worked for this query since “First” does not provide an IQueryable on which ToString could be called</span></span>  
- <span data-ttu-id="616a8-140">블로그의 지연 로드로 인해 발생 하는 쿼리입니다. 게시물과</span><span class="sxs-lookup"><span data-stu-id="616a8-140">The query resulting from the lazy-loading of blog.Posts</span></span>  
    - <span data-ttu-id="616a8-141">지연 로드가 발생 하는 키 값에 대 한 매개 변수 세부 정보를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-141">Notice the parameter details for the key value for which lazy loading is happening</span></span>  
    - <span data-ttu-id="616a8-142">기본값이 아닌 값으로 설정 된 매개 변수의 속성만 로깅됩니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-142">Only properties of the parameter that are set to non-default values are logged.</span></span> <span data-ttu-id="616a8-143">예를 들어 Size 속성은 0이 아닌 경우에만 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-143">For example, the Size property is only shown if it is non-zero.</span></span>  
- <span data-ttu-id="616a8-144">SaveChangesAsync에서 생성 되는 두 명령 하나는 게시 제목을 변경 하는 업데이트이 고, 다른 하나는 삽입 하 여 새 게시물을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-144">Two commands resulting from SaveChangesAsync; one for the update to change a post title, the other for an insert to add a new post</span></span>  
    - <span data-ttu-id="616a8-145">FK 및 Title 속성에 대 한 매개 변수 세부 정보를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-145">Notice the parameter details for the FK and Title properties</span></span>  
    - <span data-ttu-id="616a8-146">이러한 명령이 비동기적으로 실행 되 고 있음을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-146">Notice that these commands are being executed asynchronously</span></span>  

## <a name="logging-to-different-places"></a><span data-ttu-id="616a8-147">다른 위치에 로깅</span><span class="sxs-lookup"><span data-stu-id="616a8-147">Logging to different places</span></span>  

<span data-ttu-id="616a8-148">위에서 설명한 것 처럼 콘솔에 대 한 로깅은 매우 간단 합니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-148">As shown above logging to the console is super easy.</span></span> <span data-ttu-id="616a8-149">다른 종류의 [TextWriter](https://msdn.microsoft.com/library/system.io.textwriter.aspx)를 사용 하 여 메모리, 파일 등에 쉽게 기록할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-149">It’s also easy to log to memory, file, etc. by using different kinds of [TextWriter](https://msdn.microsoft.com/library/system.io.textwriter.aspx).</span></span>  

<span data-ttu-id="616a8-150">LINQ to SQL에 대해 잘 알고 있는 경우에는 LINQ to SQL에서 Log 속성이 실제 TextWriter 개체 (예: Console)로 설정 되어 있는 동안 Log 속성이 문자열을 허용 하는 메서드 (예:)로 설정 된 것을 알 수 있습니다. , Console. Write 또는 Console을 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-150">If you are familiar with LINQ to SQL you might notice that in LINQ to SQL the Log property is set to the actual TextWriter object (for example, Console.Out) while in EF the Log property is set to a method that accepts a string (for example, Console.Write or Console.Out.Write).</span></span> <span data-ttu-id="616a8-151">그 이유는 문자열에 대 한 싱크로 사용할 수 있는 대리자를 허용 하 여 TextWriter에서 EF를 분리 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-151">The reason for this is to decouple EF from TextWriter by accepting any delegate that can act as a sink for strings.</span></span> <span data-ttu-id="616a8-152">예를 들어, 일부 로깅 프레임 워크가 이미 있고 다음과 같은 로깅 메서드를 정의 한다고 가정해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-152">For example, imagine that you already have some logging framework and it defines a logging method like so:</span></span>  

``` csharp
public class MyLogger
{
    public void Log(string component, string message)
    {
        Console.WriteLine("Component: {0} Message: {1} ", component, message);
    }
}
```  

<span data-ttu-id="616a8-153">이는 다음과 같이 EF Log 속성에 후크 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-153">This could be hooked up to the EF Log property like this:</span></span>  

``` csharp
var logger = new MyLogger();
context.Database.Log = s => logger.Log("EFApp", s);
```  

## <a name="result-logging"></a><span data-ttu-id="616a8-154">결과 로깅</span><span class="sxs-lookup"><span data-stu-id="616a8-154">Result logging</span></span>  

<span data-ttu-id="616a8-155">기본로 거는 명령이 데이터베이스에 전송 되기 전에 타임 스탬프가 있는 명령 텍스트 (SQL), 매개 변수 및 "실행 중" 줄을 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-155">The default logger logs command text (SQL), parameters, and the “Executing” line with a timestamp before the command is sent to the database.</span></span> <span data-ttu-id="616a8-156">경과 된 시간을 포함 하는 "완료 됨" 줄은 명령 실행 후에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-156">A “completed” line containing elapsed time is logged following execution of the command.</span></span>  

<span data-ttu-id="616a8-157">비동기 명령의 경우 비동기 작업이 실제로 완료, 실패 또는 취소 될 때까지 "완료 됨" 줄이 기록 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-157">Note that for async commands the “completed” line is not logged until the async task actually completes, fails, or is canceled.</span></span>  

<span data-ttu-id="616a8-158">"Completed" 줄에는 명령 유형 및 실행 성공 여부에 따라 다른 정보가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-158">The “completed” line contains different information depending on the type of command and whether or not execution was successful.</span></span>  

### <a name="successful-execution"></a><span data-ttu-id="616a8-159">성공한 실행</span><span class="sxs-lookup"><span data-stu-id="616a8-159">Successful execution</span></span>  

<span data-ttu-id="616a8-160">성공적으로 완료 된 명령의 경우 "완료 된 결과:"로 완료 된 출력에는 결과를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-160">For commands that complete successfully the output is “Completed in x ms with result: “ followed by some indication of what the result was.</span></span> <span data-ttu-id="616a8-161">데이터 판독기를 반환 하는 명령의 경우 결과 표시는 반환 되는 [Dbdatareader](https://msdn.microsoft.com/library/system.data.common.dbdatareader.aspx) 의 유형입니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-161">For commands that return a data reader the result indication is the type of [DbDataReader](https://msdn.microsoft.com/library/system.data.common.dbdatareader.aspx) returned.</span></span> <span data-ttu-id="616a8-162">위에 표시 된 update 명령과 같은 정수 값을 반환 하는 명령의 경우에는 해당 정수를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-162">For commands that return an integer value such as the update command shown above the result shown is that integer.</span></span>  

### <a name="failed-execution"></a><span data-ttu-id="616a8-163">실패 한 실행</span><span class="sxs-lookup"><span data-stu-id="616a8-163">Failed execution</span></span>  

<span data-ttu-id="616a8-164">예외를 throw 하 여 실패 한 명령의 경우 출력에 예외의 메시지가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-164">For commands that fail by throwing an exception, the output contains the message from the exception.</span></span> <span data-ttu-id="616a8-165">예를 들어 SqlQuery를 사용 하 여 존재 하는 테이블을 쿼리하면 로그 출력이 다음과 같이 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-165">For example, using SqlQuery to query against a table that does exist will result in log output something like this:</span></span>  

``` SQL
SELECT * from ThisTableIsMissing
-- Executing at 5/13/2013 10:19:05 AM
-- Failed in 1 ms with error: Invalid object name 'ThisTableIsMissing'.
```  

### <a name="canceled-execution"></a><span data-ttu-id="616a8-166">취소 된 실행</span><span class="sxs-lookup"><span data-stu-id="616a8-166">Canceled execution</span></span>  

<span data-ttu-id="616a8-167">태스크가 취소 된 비동기 명령의 경우 예외가 발생 하 여 결과가 실패할 수 있습니다 .이는 취소 하려고 할 때 기본 ADO.NET 공급자가 자주 수행 하는 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-167">For async commands where the task is canceled the result could be failure with an exception, since this is what the underlying ADO.NET provider often does when an attempt is made to cancel.</span></span> <span data-ttu-id="616a8-168">이 문제가 발생 하지 않고 작업이 완전히 취소 되 면 출력은 다음과 같이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-168">If this doesn’t happen and the task is canceled cleanly then the output will look something like this:</span></span>  

```console
update Blogs set Title = 'No' where Id = -1
-- Executing asynchronously at 5/13/2013 10:21:10 AM
-- Canceled in 1 ms
```  

## <a name="changing-log-content-and-formatting"></a><span data-ttu-id="616a8-169">로그 콘텐츠 및 서식 변경</span><span class="sxs-lookup"><span data-stu-id="616a8-169">Changing log content and formatting</span></span>  

<span data-ttu-id="616a8-170">아래에서 데이터베이스 .Log 속성은 DatabaseLogFormatter 개체를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-170">Under the covers the Database.Log property makes use of a DatabaseLogFormatter object.</span></span> <span data-ttu-id="616a8-171">이 개체는 문자열과 DbContext을 허용 하는 대리자에 IDbCommandInterceptor 구현 (아래 참조)을 효과적으로 바인딩합니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-171">This object effectively binds an IDbCommandInterceptor implementation (see below) to a delegate that accepts strings and a DbContext.</span></span> <span data-ttu-id="616a8-172">즉, DatabaseLogFormatter의 메서드는 EF에서 명령을 실행 하기 전과 후에 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-172">This means that methods on DatabaseLogFormatter are called before and after the execution of commands by EF.</span></span> <span data-ttu-id="616a8-173">이러한 DatabaseLogFormatter 메서드는 로그 출력을 수집 하 고 서식을 지정 하 여 대리자에 게 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-173">These DatabaseLogFormatter methods gather and format log output and send it to the delegate.</span></span>  

### <a name="customizing-databaselogformatter"></a><span data-ttu-id="616a8-174">DatabaseLogFormatter 사용자 지정</span><span class="sxs-lookup"><span data-stu-id="616a8-174">Customizing DatabaseLogFormatter</span></span>  

<span data-ttu-id="616a8-175">DatabaseLogFormatter에서 파생 되는 새 클래스를 만들고 메서드를 적절 하 게 재정의 하 여 로깅되는 내용 및 형식을 지정 하는 방법을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-175">Changing what is logged and how it is formatted can be achieved by creating a new class that derives from DatabaseLogFormatter and overrides methods as appropriate.</span></span> <span data-ttu-id="616a8-176">재정의할 가장 일반적인 방법은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-176">The most common methods to override are:</span></span>  

- <span data-ttu-id="616a8-177">LogCommand –이를 재정의 하 여 명령이 실행 되기 전에 기록 되는 방법을 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-177">LogCommand – Override this to change how commands are logged before they are executed.</span></span> <span data-ttu-id="616a8-178">기본적으로 LogCommand는 각 매개 변수에 대해 Logcommand를 호출 합니다. 대신 재정의 또는 핸들 매개 변수에서 동일한 작업을 수행 하도록 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-178">By default LogCommand calls LogParameter for each parameter; you may choose to do the same in your override or handle parameters differently instead.</span></span>  
- <span data-ttu-id="616a8-179">LogResult –이를 재정의 하 여 명령 실행 결과를 기록 하는 방법을 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-179">LogResult – Override this to change how the outcome from executing a command is logged.</span></span>  
- <span data-ttu-id="616a8-180">LogParameter –이를 재정의 하 여 매개 변수 로깅의 형식 및 내용을 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-180">LogParameter – Override this to change the formatting and content of parameter logging.</span></span>  

<span data-ttu-id="616a8-181">예를 들어 각 명령이 데이터베이스로 전송 되기 전에 한 줄만 기록 하려는 경우를 가정해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-181">For example, suppose we wanted to log just a single line before each command is sent to the database.</span></span> <span data-ttu-id="616a8-182">이 작업은 다음 두 가지 재정의를 통해 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-182">This can be done with two overrides:</span></span>  

- <span data-ttu-id="616a8-183">LogCommand를 재정의 하 여 SQL의 단일 줄 서식 지정 및 작성</span><span class="sxs-lookup"><span data-stu-id="616a8-183">Override LogCommand to format and write the single line of SQL</span></span>  
- <span data-ttu-id="616a8-184">LogResult를 재정의 하 여 아무 작업도 수행 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-184">Override LogResult to do nothing.</span></span>  

<span data-ttu-id="616a8-185">코드는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-185">The code would look something like this:</span></span>

``` csharp
public class OneLineFormatter : DatabaseLogFormatter
{
    public OneLineFormatter(DbContext context, Action<string> writeAction)
        : base(context, writeAction)
    {
    }

    public override void LogCommand<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
        Write(string.Format(
            "Context '{0}' is executing command '{1}'{2}",
            Context.GetType().Name,
            command.CommandText.Replace(Environment.NewLine, ""),
            Environment.NewLine));
    }

    public override void LogResult<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
    }
}
```  

<span data-ttu-id="616a8-186">출력을 기록 하려면 쓰기 메서드를 호출 하기만 하면 됩니다 .이 메서드는 구성 된 쓰기 대리자로 출력을 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-186">To log output simply call the Write method which will send output to the configured write delegate.</span></span>  

<span data-ttu-id="616a8-187">(이 코드는 예제 처럼 줄 바꿈 제거를 단순화 합니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-187">(Note that this code does simplistic removal of line breaks just as an example.</span></span> <span data-ttu-id="616a8-188">복잡 한 SQL을 볼 때 제대로 작동 하지 않을 수 있습니다.)</span><span class="sxs-lookup"><span data-stu-id="616a8-188">It will likely not work well for viewing complex SQL.)</span></span>  

### <a name="setting-the-databaselogformatter"></a><span data-ttu-id="616a8-189">DatabaseLogFormatter 설정</span><span class="sxs-lookup"><span data-stu-id="616a8-189">Setting the DatabaseLogFormatter</span></span>  

<span data-ttu-id="616a8-190">새 DatabaseLogFormatter 클래스를 만든 후에는 EF를 사용 하 여 등록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-190">Once a new DatabaseLogFormatter class has been created it needs to be registered with EF.</span></span> <span data-ttu-id="616a8-191">코드 기반 구성을 사용 하 여이 작업을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-191">This is done using code-based configuration.</span></span> <span data-ttu-id="616a8-192">즉, DbContext 클래스와 동일한 어셈블리의 DbConfiguration에서 파생 되는 새 클래스를 만든 후이 새 클래스의 생성자에서 SetDatabaseLogFormatter를 호출 하는 것을 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-192">In a nutshell this means creating a new class that derives from DbConfiguration in the same assembly as your DbContext class and then calling SetDatabaseLogFormatter in the constructor of this new class.</span></span> <span data-ttu-id="616a8-193">예를 들면 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-193">For example:</span></span>  

``` csharp
public class MyDbConfiguration : DbConfiguration
{
    public MyDbConfiguration()
    {
        SetDatabaseLogFormatter(
            (context, writeAction) => new OneLineFormatter(context, writeAction));
    }
}
```  

### <a name="using-the-new-databaselogformatter"></a><span data-ttu-id="616a8-194">새 DatabaseLogFormatter 사용</span><span class="sxs-lookup"><span data-stu-id="616a8-194">Using the new DatabaseLogFormatter</span></span>  

<span data-ttu-id="616a8-195">이 새로운 DatabaseLogFormatter는 이제 데이터베이스 .Log가 설정 될 때마다 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-195">This new DatabaseLogFormatter will now be used anytime Database.Log is set.</span></span> <span data-ttu-id="616a8-196">따라서 1 부에서 코드를 실행 하면 다음과 같은 결과가 출력 됩니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-196">So, running the code from part 1 will now result in the following output:</span></span>  

```console
Context 'BlogContext' is executing command 'SELECT TOP (1) [Extent1].[Id] AS [Id], [Extent1].[Title] AS [Title]FROM [dbo].[Blogs] AS [Extent1]WHERE (N'One Unicorn' = [Extent1].[Title]) AND ([Extent1].[Title] IS NOT NULL)'
Context 'BlogContext' is executing command 'SELECT [Extent1].[Id] AS [Id], [Extent1].[Title] AS [Title], [Extent1].[BlogId] AS [BlogId]FROM [dbo].[Posts] AS [Extent1]WHERE [Extent1].[BlogId] = @EntityKeyValue1'
Context 'BlogContext' is executing command 'update [dbo].[Posts]set [Title] = @0where ([Id] = @1)'
Context 'BlogContext' is executing command 'insert [dbo].[Posts]([Title], [BlogId])values (@0, @1)select [Id]from [dbo].[Posts]where @@rowcount > 0 and [Id] = scope_identity()'
```  

## <a name="interception-building-blocks"></a><span data-ttu-id="616a8-197">가로채기 구성 요소</span><span class="sxs-lookup"><span data-stu-id="616a8-197">Interception building blocks</span></span>  

<span data-ttu-id="616a8-198">지금까지 DbContext를 사용 하 여 EF에 의해 생성 된 SQL을 기록 하는 방법을 살펴보았습니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-198">So far we have looked at how to use DbContext.Database.Log to log the SQL generated by EF.</span></span> <span data-ttu-id="616a8-199">그러나이 코드는 보다 일반적인 가로채기를 위해 일부 하위 수준 구성 요소에 비해 비교적 씬 외관입니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-199">But this code is actually a relatively thin facade over some low-level building blocks for more general interception.</span></span>  

### <a name="interception-interfaces"></a><span data-ttu-id="616a8-200">가로채기 인터페이스</span><span class="sxs-lookup"><span data-stu-id="616a8-200">Interception interfaces</span></span>  

<span data-ttu-id="616a8-201">가로채기 코드는 가로채기 인터페이스의 개념을 중심으로 빌드됩니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-201">The interception code is built around the concept of interception interfaces.</span></span> <span data-ttu-id="616a8-202">이러한 인터페이스는 IDbInterceptor에서 상속 하며 EF가 일부 작업을 수행할 때 호출 되는 메서드를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-202">These interfaces inherit from IDbInterceptor and define methods that are called when EF performs some action.</span></span> <span data-ttu-id="616a8-203">이는 가로채는 개체 형식 마다 하나의 인터페이스를 포함 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-203">The intent is to have one interface per type of object being intercepted.</span></span> <span data-ttu-id="616a8-204">예를 들어 IDbCommandInterceptor 인터페이스는 EF가 ExecuteNonQuery, ExecuteScalar, ExecuteReader 및 관련 된 메서드에 대 한 호출을 수행 하기 전에 호출 되는 메서드를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-204">For example, the IDbCommandInterceptor interface defines methods that are called before EF makes a call to ExecuteNonQuery, ExecuteScalar, ExecuteReader, and related methods.</span></span> <span data-ttu-id="616a8-205">마찬가지로이 인터페이스는 이러한 각 작업이 완료 될 때 호출 되는 메서드를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-205">Likewise, the interface defines methods that are called when each of these operations completes.</span></span> <span data-ttu-id="616a8-206">위에서 살펴본 DatabaseLogFormatter 클래스는 명령을 기록 하기 위해이 인터페이스를 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-206">The DatabaseLogFormatter class that we looked at above implements this interface to log commands.</span></span>  

### <a name="the-interception-context"></a><span data-ttu-id="616a8-207">가로채기 컨텍스트입니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-207">The interception context</span></span>  

<span data-ttu-id="616a8-208">인터셉터 인터페이스에 정의 된 메서드를 살펴보면 모든 호출에 DbInterceptionContext 형식의 개체 또는 DbCommandInterceptionContext\<\>와 같이이에서 파생 된 일부 형식의 개체가 지정 되는 것을 알 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-208">Looking at the methods defined on any of the interceptor interfaces it is apparent that every call is given an object of type DbInterceptionContext or some type derived from this such as DbCommandInterceptionContext\<\>.</span></span> <span data-ttu-id="616a8-209">이 개체는 EF에서 수행 하는 동작에 대 한 컨텍스트 정보를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-209">This object contains contextual information about the action that EF is taking.</span></span> <span data-ttu-id="616a8-210">예를 들어 DbContext를 대신 하 여 작업을 수행 하는 경우 DbContext는 DbInterceptionContext에 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-210">For example, if the action is being taken on behalf of a DbContext, then the DbContext is included in the DbInterceptionContext.</span></span> <span data-ttu-id="616a8-211">마찬가지로, 비동기적으로 실행 되는 명령의 경우 IsAsync 플래그는 DbCommandInterceptionContext에 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-211">Similarly, for commands that are being executed asynchronously, the IsAsync flag is set on DbCommandInterceptionContext.</span></span>  

### <a name="result-handling"></a><span data-ttu-id="616a8-212">결과 처리</span><span class="sxs-lookup"><span data-stu-id="616a8-212">Result handling</span></span>  

<span data-ttu-id="616a8-213">DbCommandInterceptionContext\<\> 클래스에는 Result, OriginalResult, Exception 및 Originalresult 이라는 속성이 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-213">The DbCommandInterceptionContext\<\> class contains a properties called Result, OriginalResult, Exception, and OriginalException.</span></span> <span data-ttu-id="616a8-214">이러한 속성은 작업이 실행 되기 전에 호출 되는 가로채기 메서드를 호출 하는 경우 null/0으로 설정 됩니다. 즉, ... 메서드를 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-214">These properties are set to null/zero for calls to the interception methods that are called before the operation is executed — that is, for the …Executing methods.</span></span> <span data-ttu-id="616a8-215">작업이 실행 되 고 성공 하면 Result와 OriginalResult가 작업의 결과로 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-215">If the operation is executed and succeeds, then Result and OriginalResult are set to the result of the operation.</span></span> <span data-ttu-id="616a8-216">이러한 값은 작업이 실행 된 후 호출 되는 가로채기 메서드에서 관찰 될 수 있습니다. 즉, ... 메서드를 실행 했습니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-216">These values can then be observed in the interception methods that are called after the operation has executed — that is, on the …Executed methods.</span></span> <span data-ttu-id="616a8-217">마찬가지로 작업에서을 throw 하는 경우 Exception 및 OriginalException 속성이 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-217">Likewise, if the operation throws, then the Exception and OriginalException properties will be set.</span></span>  

#### <a name="suppressing-execution"></a><span data-ttu-id="616a8-218">실행 억제</span><span class="sxs-lookup"><span data-stu-id="616a8-218">Suppressing execution</span></span>  

<span data-ttu-id="616a8-219">인터셉터가 명령 실행 전에 결과 속성을 설정 하는 경우 (... 메서드를 실행 하는 경우 EF는 실제로 명령을 실행 하려고 시도 하지 않고 단순히 결과 집합을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-219">If an interceptor sets the Result property before the command has executed (in one of the …Executing methods) then EF will not attempt to actually execute the command, but will instead just use the result set.</span></span> <span data-ttu-id="616a8-220">즉, 인터셉터는 명령이 실행 되지 않도록 할 수 있지만 명령이 실행 된 것 처럼 EF를 계속 합니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-220">In other words, the interceptor can suppress execution of the command but have EF continue as if the command had been executed.</span></span>  

<span data-ttu-id="616a8-221">이를 사용 하는 방법의 예는 일반적으로 래핑 공급자를 사용 하 여 수행 된 명령 일괄 처리입니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-221">An example of how this might be used is the command batching that has traditionally been done with a wrapping provider.</span></span> <span data-ttu-id="616a8-222">인터셉터는 나중에 일괄 처리로 명령을 저장 하지만 명령이 정상적으로 실행 되었음을 EF로 "간주" 합니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-222">The interceptor would store the command for later execution as a batch but would “pretend” to EF that the command had executed as normal.</span></span> <span data-ttu-id="616a8-223">일괄 처리를 구현 하는 데이 두 가지 이상의 작업이 필요 하지만이는 가로채기 결과를 변경 하는 방법의 예입니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-223">Note that it requires more than this to implement batching, but this is an example of how changing the interception result might be used.</span></span>  

<span data-ttu-id="616a8-224">다음 중 하나에서 예외 속성을 설정 하 여 실행을 억제할 수도 있습니다. 메서드를 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-224">Execution can also be suppressed by setting the Exception property in one of the …Executing methods.</span></span> <span data-ttu-id="616a8-225">이렇게 하면 지정 된 예외를 throw 하 여 작업 실행이 실패 한 것 처럼 EF가 계속 됩니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-225">This causes EF to continue as if execution of the operation had failed by throwing the given exception.</span></span> <span data-ttu-id="616a8-226">이로 인해 응용 프로그램의 작동이 중단 될 수 있지만 일시적인 예외 또는 EF에서 처리 하는 다른 예외가 발생할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-226">This may, of course, cause the application to crash, but it may also be a transient exception or some other exception that is handled by EF.</span></span> <span data-ttu-id="616a8-227">예를 들어 명령 실행이 실패 하면 테스트 환경에서 응용 프로그램의 동작을 테스트 하는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-227">For example, this could be used in test environments to test the behavior of an application when command execution fails.</span></span>  

#### <a name="changing-the-result-after-execution"></a><span data-ttu-id="616a8-228">실행 후 결과 변경</span><span class="sxs-lookup"><span data-stu-id="616a8-228">Changing the result after execution</span></span>  

<span data-ttu-id="616a8-229">명령을 실행 한 후 인터셉터가 결과 속성을 설정 하는 경우 (... 실행 된 메서드) EF는 실제로 작업에서 반환 된 결과 대신 변경 된 결과를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-229">If an interceptor sets the Result property after the command has executed (in one of the …Executed methods) then EF will use the changed result instead of the result that was actually returned from the operation.</span></span> <span data-ttu-id="616a8-230">마찬가지로, 인터셉터에서 명령이 실행 된 후에 예외 속성을 설정 하는 경우 EF는 작업이 예외를 throw 한 것 처럼 set 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-230">Similarly, if an interceptor sets the Exception property after the command has executed, then EF will throw the set exception as if the operation had thrown the exception.</span></span>  

<span data-ttu-id="616a8-231">인터셉터는 예외를 throw 하지 않아야 함을 나타내기 위해 Exception 속성을 null로 설정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-231">An interceptor can also set the Exception property to null to indicate that no exception should be thrown.</span></span> <span data-ttu-id="616a8-232">이는 작업 실행이 실패 한 경우에 유용할 수 있지만 인터셉터가 작업에 성공한 것 처럼 계속 진행 합니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-232">This can be useful if execution of the operation failed but the interceptor wishes EF to continue as if the operation had succeeded.</span></span> <span data-ttu-id="616a8-233">이 경우에도 EF가 계속 해 서 작동 하는 결과 값을 갖도록 결과를 설정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-233">This usually also involves setting the Result so that EF has some result value to work with as it continues.</span></span>  

#### <a name="originalresult-and-originalexception"></a><span data-ttu-id="616a8-234">OriginalResult 및 Originalresult</span><span class="sxs-lookup"><span data-stu-id="616a8-234">OriginalResult and OriginalException</span></span>  

<span data-ttu-id="616a8-235">EF가 작업을 실행 한 후 실행이 실패 하면 Result 및 OriginalResult 속성을 설정 하 고, 예외와 함께 실행이 실패 한 경우에는 Exception 및 Originalresult 속성을 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-235">After EF has executed an operation it will set either the Result and OriginalResult properties if execution did not fail or the Exception and OriginalException properties if execution failed with an exception.</span></span>  

<span data-ttu-id="616a8-236">OriginalResult 및 Originalresult 속성은 읽기 전용 이며 실제로 작업을 실행 한 후에만 EF에 의해 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-236">The OriginalResult and OriginalException properties are read-only and are only set by EF after actually executing an operation.</span></span> <span data-ttu-id="616a8-237">이러한 속성은 인터셉터로 설정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-237">These properties cannot be set by interceptors.</span></span> <span data-ttu-id="616a8-238">즉, 모든 인터셉터는 작업이 실행 될 때 발생 한 실제 예외 또는 결과가 아닌 다른 인터셉터에 의해 설정 된 예외 나 결과를 구분할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-238">This means that any interceptor can distinguish between an exception or result that has been set by some other interceptor as opposed to the real exception or result that occurred when the operation was executed.</span></span>  

### <a name="registering-interceptors"></a><span data-ttu-id="616a8-239">인터셉터 등록</span><span class="sxs-lookup"><span data-stu-id="616a8-239">Registering interceptors</span></span>  

<span data-ttu-id="616a8-240">하나 이상의 가로채기 인터페이스를 구현 하는 클래스를 만든 후에는 DbInterception 클래스를 사용 하 여 EF에 등록할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-240">Once a class that implements one or more of the interception interfaces has been created it can be registered with EF using the DbInterception class.</span></span> <span data-ttu-id="616a8-241">예를 들면 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-241">For example:</span></span>  

``` csharp
DbInterception.Add(new NLogCommandInterceptor());
```  

<span data-ttu-id="616a8-242">DbConfiguration 코드 기반 구성 메커니즘을 사용 하 여 앱 도메인 수준에서 인터셉터를 등록할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-242">Interceptors can also be registered at the app-domain level using the DbConfiguration code-based configuration mechanism.</span></span>  

### <a name="example-logging-to-nlog"></a><span data-ttu-id="616a8-243">예: NLog에 로깅</span><span class="sxs-lookup"><span data-stu-id="616a8-243">Example: Logging to NLog</span></span>  

<span data-ttu-id="616a8-244">여기에 모두 IDbCommandInterceptor 및 [Nlog](https://nlog-project.org/) 를 사용 하는 예제를 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-244">Let’s put all this together into an example that using IDbCommandInterceptor and [NLog](https://nlog-project.org/) to:</span></span>  

- <span data-ttu-id="616a8-245">비 비동기식으로 실행 되는 명령에 대 한 경고 기록</span><span class="sxs-lookup"><span data-stu-id="616a8-245">Log a warning for any command that is executed non-asynchronously</span></span>  
- <span data-ttu-id="616a8-246">실행 시 throw 되는 명령에 대 한 오류를 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-246">Log an error for any command that throws when executed</span></span>  

<span data-ttu-id="616a8-247">다음은 위와 같이 등록 해야 하는 로깅을 수행 하는 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-247">Here’s the class that does the logging, which should be registered as shown above:</span></span>  

``` csharp
public class NLogCommandInterceptor : IDbCommandInterceptor
{
    private static readonly Logger Logger = LogManager.GetCurrentClassLogger();

    public void NonQueryExecuting(
        DbCommand command, DbCommandInterceptionContext<int> interceptionContext)
    {
        LogIfNonAsync(command, interceptionContext);
    }

    public void NonQueryExecuted(
        DbCommand command, DbCommandInterceptionContext<int> interceptionContext)
    {
        LogIfError(command, interceptionContext);
    }

    public void ReaderExecuting(
        DbCommand command, DbCommandInterceptionContext<DbDataReader> interceptionContext)
    {
        LogIfNonAsync(command, interceptionContext);
    }

    public void ReaderExecuted(
        DbCommand command, DbCommandInterceptionContext<DbDataReader> interceptionContext)
    {
        LogIfError(command, interceptionContext);
    }

    public void ScalarExecuting(
        DbCommand command, DbCommandInterceptionContext<object> interceptionContext)
    {
        LogIfNonAsync(command, interceptionContext);
    }

    public void ScalarExecuted(
        DbCommand command, DbCommandInterceptionContext<object> interceptionContext)
    {
        LogIfError(command, interceptionContext);
    }

    private void LogIfNonAsync<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
        if (!interceptionContext.IsAsync)
        {
            Logger.Warn("Non-async command used: {0}", command.CommandText);
        }
    }

    private void LogIfError<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
        if (interceptionContext.Exception != null)
        {
            Logger.Error("Command {0} failed with exception {1}",
                command.CommandText, interceptionContext.Exception);
        }
    }
}
```  

<span data-ttu-id="616a8-248">이 코드는 가로채기 컨텍스트를 사용 하 여 명령이 비동기적으로 실행 되지 않는 경우를 검색 하 고 명령을 실행 하는 동안 오류가 발생 한 경우를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="616a8-248">Notice how this code uses the interception context to discover when a command is being executed non-asynchronously and to discover when there was an error executing a command.</span></span>  
