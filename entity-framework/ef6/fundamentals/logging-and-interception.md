---
title: 로깅 및 데이터베이스 작업-EF6 가로채기
author: divega
ms.date: 2016-10-23
ms.assetid: b5ee7eb1-88cc-456e-b53c-c67e24c3f8ca
ms.openlocfilehash: 9a8be81af45d9f27caa8c26f66d219dc568b6604
ms.sourcegitcommit: 0d36e8ff0892b7f034b765b15e041f375f88579a
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/09/2018
ms.locfileid: "44251273"
---
# <a name="logging-and-intercepting-database-operations"></a><span data-ttu-id="35e2b-102">로깅 및 데이터베이스 작업 가로채기</span><span class="sxs-lookup"><span data-stu-id="35e2b-102">Logging and intercepting database operations</span></span>
> [!NOTE]
> <span data-ttu-id="35e2b-103">**EF6 이상만** - 이 페이지에서 다루는 기능, API 등은 Entity Framework 6에 도입되었습니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-103">**EF6 Onwards Only** - The features, APIs, etc. discussed in this page were introduced in Entity Framework 6.</span></span> <span data-ttu-id="35e2b-104">이전 버전을 사용하는 경우 이 정보의 일부 또는 전체가 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-104">If you are using an earlier version, some or all of the information does not apply.</span></span>  

<span data-ttu-id="35e2b-105">Entity Framework 명령을 데이터베이스에이 명령을 보냅니다 언제 든 지 Entity Framework 6을 사용 하 여 시작 하는 응용 프로그램 코드에서 가로챌 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-105">Starting with Entity Framework 6, anytime Entity Framework sends a command to the database this command can be intercepted by application code.</span></span> <span data-ttu-id="35e2b-106">이 SQL 로깅을 위한 가장 많이 사용 됩니다 있지만 수정 또는 중단 명령을 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-106">This is most commonly used for logging SQL, but can also be used to modify or abort the command.</span></span>  

<span data-ttu-id="35e2b-107">특히, EF에 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-107">Specifically, EF includes:</span></span>  

- <span data-ttu-id="35e2b-108">LINQ to SQL에서에서 DataContext.Log 비슷합니다 컨텍스트에 대 한 로그 속성</span><span class="sxs-lookup"><span data-stu-id="35e2b-108">A Log property for the context similar to DataContext.Log in LINQ to SQL</span></span>  
- <span data-ttu-id="35e2b-109">콘텐츠 및 로그로 전송 하는 출력의 서식 지정을 사용자 지정 하는 메커니즘</span><span class="sxs-lookup"><span data-stu-id="35e2b-109">A mechanism to customize the content and formatting of the output sent to the log</span></span>  
- <span data-ttu-id="35e2b-110">컨트롤/유연성을 제공 하는 인터 셉 션 용 낮은 수준의 구성 요소</span><span class="sxs-lookup"><span data-stu-id="35e2b-110">Low-level building blocks for interception giving greater control/flexibility</span></span>  

## <a name="context-log-property"></a><span data-ttu-id="35e2b-111">상황에 맞는 로그 속성</span><span class="sxs-lookup"><span data-stu-id="35e2b-111">Context Log property</span></span>  

<span data-ttu-id="35e2b-112">문자열을 사용 하는 모든 메서드에 대 한 대리자를 DbContext.Database.Log 속성을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-112">The DbContext.Database.Log property can be set to a delegate for any method that takes a string.</span></span> <span data-ttu-id="35e2b-113">가장 일반적으로 "Write" 메서드는 textwriter로 설정 하 여 모든 TextWriter를 사용 하 여 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-113">Most commonly it is used with any TextWriter by setting it to the “Write” method of that TextWriter.</span></span> <span data-ttu-id="35e2b-114">현재 컨텍스트에서 생성 된 모든 SQL 기록기에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-114">All SQL generated by the current context will be logged to that writer.</span></span> <span data-ttu-id="35e2b-115">예를 들어, 다음 코드를 콘솔에 SQL 로깅됩니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-115">For example, the following code will log SQL to the console:</span></span>  

``` csharp
using (var context = new BlogContext())
{
    context.Database.Log = Console.Write;

    // Your code here...
}
```  

<span data-ttu-id="35e2b-116">해당 컨텍스트를 확인 합니다. Database.Log은 Console.Write로 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-116">Notice that context.Database.Log is set to Console.Write.</span></span> <span data-ttu-id="35e2b-117">이것이 SQL 콘솔에 로그인 하는 데 필요한 모든입니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-117">This is all that is needed to log SQL to the console.</span></span>  

<span data-ttu-id="35e2b-118">일부 출력을 볼 수 있도록 몇 가지 간단한 쿼리/삽입/업데이트 코드를 추가 해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-118">Let’s add some simple query/insert/update code so that we can see some output:</span></span>  

``` csharp
using (var context = new BlogContext())
{
    context.Database.Log = Console.Write;

    var blog = context.Blogs.First(b => b.Title == "One Unicorn");

    blog.Posts.First().Title = "Green Eggs and Ham";

    blog.Posts.Add(new Post { Title = "I do not like them!" });

    context.SaveChangesAsync().Wait();
}
```  

<span data-ttu-id="35e2b-119">다음과 같은 출력이 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-119">This will generate the following output:</span></span>  

``` SQL
SELECT TOP (1)
    [Extent1].[Id] AS [Id],
    [Extent1].[Title] AS [Title]
    FROM [dbo].[Blogs] AS [Extent1]
    WHERE (N'One Unicorn' = [Extent1].[Title]) AND ([Extent1].[Title] IS NOT NULL)
-- Executing at 10/8/2013 10:55:41 AM -07:00
-- Completed in 4 ms with result: SqlDataReader

SELECT
    [Extent1].[Id] AS [Id],
    [Extent1].[Title] AS [Title],
    [Extent1].[BlogId] AS [BlogId]
    FROM [dbo].[Posts] AS [Extent1]
    WHERE [Extent1].[BlogId] = @EntityKeyValue1
-- EntityKeyValue1: '1' (Type = Int32)
-- Executing at 10/8/2013 10:55:41 AM -07:00
-- Completed in 2 ms with result: SqlDataReader

UPDATE [dbo].[Posts]
SET [Title] = @0
WHERE ([Id] = @1)
-- @0: 'Green Eggs and Ham' (Type = String, Size = -1)
-- @1: '1' (Type = Int32)
-- Executing asynchronously at 10/8/2013 10:55:41 AM -07:00
-- Completed in 12 ms with result: 1

INSERT [dbo].[Posts]([Title], [BlogId])
VALUES (@0, @1)
SELECT [Id]
FROM [dbo].[Posts]
WHERE @@ROWCOUNT > 0 AND [Id] = scope_identity()
-- @0: 'I do not like them!' (Type = String, Size = -1)
-- @1: '1' (Type = Int32)
-- Executing asynchronously at 10/8/2013 10:55:41 AM -07:00
-- Completed in 2 ms with result: SqlDataReader
```  

<span data-ttu-id="35e2b-120">(이 모든 데이터베이스 초기화 이미 발생 한 것으로 가정 하는 출력 note 합니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-120">(Note that this is the output assuming any database initialization has already happened.</span></span> <span data-ttu-id="35e2b-121">데이터베이스 초기화 있을 것을 이미 오류가 발생 하지 하는 경우 모든 작업 마이그레이션을 보여 주는 더 많은 출력은 내부적으로 확인 하거나 새 데이터베이스를 만듭니다.)</span><span class="sxs-lookup"><span data-stu-id="35e2b-121">If database initialization had not already happened then there would be a lot more output showing all the work Migrations does under the covers to check for or create a new database.)</span></span>  

## <a name="what-gets-logged"></a><span data-ttu-id="35e2b-122">로그를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-122">What gets logged?</span></span>  

<span data-ttu-id="35e2b-123">다음의 모든 로그 속성이 설정 된 경우 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-123">When the Log property is set all of the following will be logged:</span></span>  

- <span data-ttu-id="35e2b-124">SQL 명령의 모든 다양 한 종류입니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-124">SQL for all different kinds of commands.</span></span> <span data-ttu-id="35e2b-125">예를 들어:</span><span class="sxs-lookup"><span data-stu-id="35e2b-125">For example:</span></span>  
    - <span data-ttu-id="35e2b-126">기본 LINQ 쿼리, eSQL 쿼리 및 SqlQuery 같은 방법 중에서 원시 쿼리를 포함 하 여 쿼리</span><span class="sxs-lookup"><span data-stu-id="35e2b-126">Queries, including normal LINQ queries, eSQL queries, and raw queries from methods such as SqlQuery</span></span>  
    - <span data-ttu-id="35e2b-127">삽입, 업데이트 및 삭제 SaveChanges의 일부로 생성</span><span class="sxs-lookup"><span data-stu-id="35e2b-127">Inserts, updates, and deletes generated as part of SaveChanges</span></span>  
    - <span data-ttu-id="35e2b-128">예: 지연 로드 하 여 생성 된 쿼리를 로드 하는 관계</span><span class="sxs-lookup"><span data-stu-id="35e2b-128">Relationship loading queries such as those generated by lazy loading</span></span>  
- <span data-ttu-id="35e2b-129">매개 변수</span><span class="sxs-lookup"><span data-stu-id="35e2b-129">Parameters</span></span>  
- <span data-ttu-id="35e2b-130">명령을 비동기적으로 실행 되는 여부</span><span class="sxs-lookup"><span data-stu-id="35e2b-130">Whether or not the command is being executed asynchronously</span></span>  
- <span data-ttu-id="35e2b-131">명령 실행을 시작할 때를 나타내는 타임 스탬프</span><span class="sxs-lookup"><span data-stu-id="35e2b-131">A timestamp indicating when the command started executing</span></span>  
- <span data-ttu-id="35e2b-132">명령이 성공적으로 완료 된 예외를 throw 하 여 또는 비동기에 대 한 실패 여부 취소 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-132">Whether or not the command completed successfully, failed by throwing an exception, or, for async, was canceled</span></span>  
- <span data-ttu-id="35e2b-133">결과 값의 일부 표시</span><span class="sxs-lookup"><span data-stu-id="35e2b-133">Some indication of the result value</span></span>  
- <span data-ttu-id="35e2b-134">명령을 실행 하는 데 걸리는 시간의 대략적인 크기입니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-134">The approximate amount of time it took to execute the command.</span></span> <span data-ttu-id="35e2b-135">이 결과 개체를 다시 가져오는 중에 명령을 보내기에서 시간 note 합니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-135">Note that this is the time from sending the command to getting the result object back.</span></span> <span data-ttu-id="35e2b-136">결과 읽을 시간이 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-136">It does not include time to read the results.</span></span>  

<span data-ttu-id="35e2b-137">위 예제 출력을 보면 각 기록 4 개 명령은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-137">Looking at the example output above, each of the four commands logged are:</span></span>  

- <span data-ttu-id="35e2b-138">컨텍스트에 대 한 호출에서 발생 하는 쿼리. Blogs.First</span><span class="sxs-lookup"><span data-stu-id="35e2b-138">The query resulting from the call to context.Blogs.First</span></span>  
    - <span data-ttu-id="35e2b-139">이후이 쿼리에 대 한 SQL 가져오기의 ToString 메서드는 작동 하지는 "First"는 ToString 호출 IQueryable 제공 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-139">Notice that the ToString method of getting the SQL would not have worked for this query since “First” does not provide an IQueryable on which ToString could be called</span></span>  
- <span data-ttu-id="35e2b-140">블로그의 지연 로드에서 발생 하는 쿼리. 게시물</span><span class="sxs-lookup"><span data-stu-id="35e2b-140">The query resulting from the lazy-loading of blog.Posts</span></span>  
    - <span data-ttu-id="35e2b-141">발생 하는 지연 로드에 대 한 키 값에 대 한 매개 변수 세부 정보는 통지</span><span class="sxs-lookup"><span data-stu-id="35e2b-141">Notice the parameter details for the key value for which lazy loading is happening</span></span>  
    - <span data-ttu-id="35e2b-142">기본이 아닌 값으로 설정 된 매개 변수 속성만 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-142">Only properties of the parameter that are set to non-default values are logged.</span></span> <span data-ttu-id="35e2b-143">예를 들어, 크기 속성은 0이 아닌 경우 것을 표시만 됩니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-143">For example, the Size property is only shown if it is non-zero.</span></span>  
- <span data-ttu-id="35e2b-144">SaveChangesAsync;에서 발생 하는 두 개의 명령 새 게시를 추가 하려면 삽입에 대 한 다른 게시물 제목을 변경에 대 한 업데이트에 대 한</span><span class="sxs-lookup"><span data-stu-id="35e2b-144">Two commands resulting from SaveChangesAsync; one for the update to change a post title, the other for an insert to add a new post</span></span>  
    - <span data-ttu-id="35e2b-145">FK 및 Title 속성에 대 한 매개 변수 세부 정보를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-145">Notice the parameter details for the FK and Title properties</span></span>  
    - <span data-ttu-id="35e2b-146">이러한 명령을 비동기적으로 실행 되는 알 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-146">Notice that these commands are being executed asynchronously</span></span>  

## <a name="logging-to-different-places"></a><span data-ttu-id="35e2b-147">다른 위치에 로깅</span><span class="sxs-lookup"><span data-stu-id="35e2b-147">Logging to different places</span></span>  

<span data-ttu-id="35e2b-148">로깅이 위에 표시 된 대로 콘솔은 아주 간단 합니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-148">As shown above logging to the console is super easy.</span></span> <span data-ttu-id="35e2b-149">메모리, 파일 등 다양 한 종류를 사용 하 여 로그인에 쉽습니다입니다 [TextWriter](https://msdn.microsoft.com/library/system.io.textwriter.aspx)합니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-149">It’s also easy to log to memory, file, etc. by using different kinds of [TextWriter](https://msdn.microsoft.com/library/system.io.textwriter.aspx).</span></span>  

<span data-ttu-id="35e2b-150">익숙한 경우 linq to SQL에서 LINQ to SQL Log 속성은 실제 TextWriter 개체로 설정 (예: Console.Out) 하는 동안 로그 설정 (예: 문자열을 허용 하는 메서드에 EF의 않았음을 알 수 있습니다 Console.Write 또는 Console.Out.Write).</span><span class="sxs-lookup"><span data-stu-id="35e2b-150">If you are familiar with LINQ to SQL you might notice that in LINQ to SQL the Log property is set to the actual TextWriter object (for example, Console.Out) while in EF the Log property is set to a method that accepts a string (for example, Console.Write or Console.Out.Write).</span></span> <span data-ttu-id="35e2b-151">이러한 이유로 문자열에 대 한 싱크로 작동할 수 있는 모든 대리자를 그대로 사용 하 여 EF에서 TextWriter 분리 하기 위해서입니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-151">The reason for this is to decouple EF from TextWriter by accepting any delegate that can act as a sink for strings.</span></span> <span data-ttu-id="35e2b-152">예를 들어, 일부 로깅 프레임 워크를 이미 있는 고 로깅 메서드를 정의 한다고 가정 다음과 같이 합니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-152">For example, imagine that you already have some logging framework and it defines a logging method like so:</span></span>  

``` csharp
public class MyLogger
{
    public void Log(string component, string message)
    {
        Console.WriteLine("Component: {0} Message: {1} ", component, message);
    }
}
```  

<span data-ttu-id="35e2b-153">이 같이 EF Log 속성을 연결할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-153">This could be hooked up to the EF Log property like this:</span></span>  

``` csharp
var logger = new MyLogger();
context.Database.Log = s => logger.Log("EFApp", s);
```  

## <a name="result-logging"></a><span data-ttu-id="35e2b-154">결과 로깅</span><span class="sxs-lookup"><span data-stu-id="35e2b-154">Result logging</span></span>  

<span data-ttu-id="35e2b-155">기본으로 거 명령이 데이터베이스에 전송 되기 전에 타임 스탬프를 사용 하 여 SQL 명령 텍스트, 매개 변수 및 "실행" 줄 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-155">The default logger logs command text (SQL), parameters, and the “Executing” line with a timestamp before the command is sent to the database.</span></span> <span data-ttu-id="35e2b-156">경과 된 시간을 포함 하 "완료 됨된" 줄이 기록 된 다음 명령 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-156">A “completed” line containing elapsed time is logged following execution of the command.</span></span>  

<span data-ttu-id="35e2b-157">비동기 작업이 실제로 완료, 실패 되거나 취소 될 때까지 비동기에 대 한 "완료 됨된" 줄을 명령에 기록 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-157">Note that for async commands the “completed” line is not logged until the async task actually completes, fails, or is canceled.</span></span>  

<span data-ttu-id="35e2b-158">"완료 됨된" 줄 유형 명령 및 실행 성공 여부에 따라 다른 정보를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-158">The “completed” line contains different information depending on the type of command and whether or not execution was successful.</span></span>  

### <a name="successful-execution"></a><span data-ttu-id="35e2b-159">성공적으로 실행</span><span class="sxs-lookup"><span data-stu-id="35e2b-159">Successful execution</span></span>  

<span data-ttu-id="35e2b-160">명령의 출력을 성공적으로 완료 하는 디렉터리는 "결과 사용 하 여 ms x에서 완료:" 뒤에 결과 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-160">For commands that complete successfully the output is “Completed in x ms with result: “ followed by some indication of what the result was.</span></span> <span data-ttu-id="35e2b-161">결과 데이터 판독기를 반환 하는 명령 표시의 형식인 [DbDataReader](https://msdn.microsoft.com/library/system.data.common.dbdatareader.aspx) 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-161">For commands that return a data reader the result indication is the type of [DbDataReader](https://msdn.microsoft.com/library/system.data.common.dbdatareader.aspx) returned.</span></span> <span data-ttu-id="35e2b-162">업데이트와 같은 정수 값을 반환 하는 명령에 대 한 표시 된 것 처럼 위에 표시 된 명령에는 해당 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-162">For commands that return an integer value such as the update command shown above the result shown is that integer.</span></span>  

### <a name="failed-execution"></a><span data-ttu-id="35e2b-163">실패 한 실행</span><span class="sxs-lookup"><span data-stu-id="35e2b-163">Failed execution</span></span>  

<span data-ttu-id="35e2b-164">예외가 발생 하면 실패 하는 명령에 대 한 출력 메시지는 예외를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-164">For commands that fail by throwing an exception, the output contains the message from the exception.</span></span> <span data-ttu-id="35e2b-165">예를 들어, SqlQuery 존재 하는 테이블에 대해 쿼리를 사용 하 여 결과 로그에서 출력 같이:</span><span class="sxs-lookup"><span data-stu-id="35e2b-165">For example, using SqlQuery to query against a table that does exist will result in log output something like this:</span></span>  

``` SQL
SELECT * from ThisTableIsMissing
-- Executing at 5/13/2013 10:19:05 AM
-- Failed in 1 ms with error: Invalid object name 'ThisTableIsMissing'.
```  

### <a name="canceled-execution"></a><span data-ttu-id="35e2b-166">취소 된 실행</span><span class="sxs-lookup"><span data-stu-id="35e2b-166">Canceled execution</span></span>  

<span data-ttu-id="35e2b-167">작업이 취소 되는 비동기 명령에 대 한 기본 ADO.NET 공급자 자주 수행 취소 하려고 시도 하는 경우 이므로 결과 예외를 사용 하 여 오류를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-167">For async commands where the task is canceled the result could be failure with an exception, since this is what the underlying ADO.NET provider often does when an attempt is made to cancel.</span></span> <span data-ttu-id="35e2b-168">그렇지 않은 경우 출력은 다음과 같아야 하는 다음 작업이 정상적으로 취소 되:</span><span class="sxs-lookup"><span data-stu-id="35e2b-168">If this doesn’t happen and the task is canceled cleanly then the output will look something like this:</span></span>  

```  
update Blogs set Title = 'No' where Id = -1
-- Executing asynchronously at 5/13/2013 10:21:10 AM
-- Canceled in 1 ms
```  

## <a name="changing-log-content-and-formatting"></a><span data-ttu-id="35e2b-169">변경 로그 콘텐츠 및 서식 지정</span><span class="sxs-lookup"><span data-stu-id="35e2b-169">Changing log content and formatting</span></span>  

<span data-ttu-id="35e2b-170">내부적으로 속성을 사용 하면 Database.Log DatabaseLogFormatter 개체를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-170">Under the covers the Database.Log property makes use of a DatabaseLogFormatter object.</span></span> <span data-ttu-id="35e2b-171">이 개체는 효과적으로 문자열 및 DbContext를 허용 하는 대리자를 IDbCommandInterceptor 구현을 (아래 참조)를 바인딩합니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-171">This object effectively binds an IDbCommandInterceptor implementation (see below) to a delegate that accepts strings and a DbContext.</span></span> <span data-ttu-id="35e2b-172">즉, DatabaseLogFormatter 메서드는 호출 명령이 실행 전후 EF에서.</span><span class="sxs-lookup"><span data-stu-id="35e2b-172">This means that methods on DatabaseLogFormatter are called before and after the execution of commands by EF.</span></span> <span data-ttu-id="35e2b-173">이러한 DatabaseLogFormatter 메서드 수집 로그 출력 형식 및 대리자에 게 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-173">These DatabaseLogFormatter methods gather and format log output and send it to the delegate.</span></span>  

### <a name="customizing-databaselogformatter"></a><span data-ttu-id="35e2b-174">사용자 지정 DatabaseLogFormatter</span><span class="sxs-lookup"><span data-stu-id="35e2b-174">Customizing DatabaseLogFormatter</span></span>  

<span data-ttu-id="35e2b-175">로깅되는 및의 서식 지정 방법을 변경 DatabaseLogFormatter에서 파생 되 고 적절 하 게 메서드를 재정의 하는 새 클래스를 만들어 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-175">Changing what is logged and how it is formatted can be achieved by creating a new class that derives from DatabaseLogFormatter and overrides methods as appropriate.</span></span> <span data-ttu-id="35e2b-176">재정의 하는 가장 일반적인 방법은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-176">The most common methods to override are:</span></span>  

- <span data-ttu-id="35e2b-177">LogCommand-이 명령을 실행 하기 전에 기록 되는 방식 변경 설정을 재정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-177">LogCommand – Override this to change how commands are logged before they are executed.</span></span> <span data-ttu-id="35e2b-178">LogParameter; 각 매개 변수에 대해 LogCommand 기본적으로 호출 재정의에서 동일한 작업을 수행 하거나 매개 변수를 다르게 처리 하도록 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-178">By default LogCommand calls LogParameter for each parameter; you may choose to do the same in your override or handle parameters differently instead.</span></span>  
- <span data-ttu-id="35e2b-179">LogResult – 명령 실행에서 결과 기록 되는 방식을 변경 하려면이 옵션을 재정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-179">LogResult – Override this to change how the outcome from executing a command is logged.</span></span>  
- <span data-ttu-id="35e2b-180">LogParameter – 서식 및 매개 변수 로깅의 내용을 변경 하려면이 옵션을 재정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-180">LogParameter – Override this to change the formatting and content of parameter logging.</span></span>  

<span data-ttu-id="35e2b-181">예를 들어, 각 명령을 데이터베이스에 전송 되기 전에 한 줄을 기록할 한다고 가정해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-181">For example, suppose we wanted to log just a single line before each command is sent to the database.</span></span> <span data-ttu-id="35e2b-182">이 두 가지 재정의 사용 하 여 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-182">This can be done with two overrides:</span></span>  

- <span data-ttu-id="35e2b-183">서식을 지정 하 고 SQL 단일 줄 LogCommand 재정의</span><span class="sxs-lookup"><span data-stu-id="35e2b-183">Override LogCommand to format and write the single line of SQL</span></span>  
- <span data-ttu-id="35e2b-184">아무 작업도 하지 않으려면 LogResult를 재정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-184">Override LogResult to do nothing.</span></span>  

<span data-ttu-id="35e2b-185">코드를 다음과 같이 보입니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-185">The code would look something like this:</span></span>

``` csharp
public class OneLineFormatter : DatabaseLogFormatter
{
    public OneLineFormatter(DbContext context, Action<string> writeAction)
        : base(context, writeAction)
    {
    }

    public override void LogCommand<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
        Write(string.Format(
            "Context '{0}' is executing command '{1}'{2}",
            Context.GetType().Name,
            command.CommandText.Replace(Environment.NewLine, ""),
            Environment.NewLine));
    }

    public override void LogResult<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
    }
}
```  

<span data-ttu-id="35e2b-186">기록할 단순히 호출 구성된 쓰기 대리자에 출력을 보내는 Write 메서드에 출력 합니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-186">To log output simply call the Write method which will send output to the configured write delegate.</span></span>  

<span data-ttu-id="35e2b-187">(이 코드 예제 처럼 간단한 줄 바꿈 제거 않은 것을 참고 합니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-187">(Note that this code does simplistic removal of line breaks just as an example.</span></span> <span data-ttu-id="35e2b-188">가능성이 작동 하지 않습니다 복잡 한 SQL 보기에 적합 합니다.)</span><span class="sxs-lookup"><span data-stu-id="35e2b-188">It will likely not work well for viewing complex SQL.)</span></span>  

### <a name="setting-the-databaselogformatter"></a><span data-ttu-id="35e2b-189">DatabaseLogFormatter 설정</span><span class="sxs-lookup"><span data-stu-id="35e2b-189">Setting the DatabaseLogFormatter</span></span>  

<span data-ttu-id="35e2b-190">EF를 사용 하 여 등록할 새 DatabaseLogFormatter 클래스를 만든 후에 해당 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-190">Once a new DatabaseLogFormatter class has been created it needs to be registered with EF.</span></span> <span data-ttu-id="35e2b-191">이렇게 하는 코드 기반 구성을 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-191">This is done using code-based configuration.</span></span> <span data-ttu-id="35e2b-192">간단히 말해이 DbContext 클래스와 동일한 어셈블리에서 DbConfiguration에서 파생 되는 새 클래스를 만들고 호출한 다음이 새 클래스의 생성자에서 SetDatabaseLogFormatter 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-192">In a nutshell this means creating a new class that derives from DbConfiguration in the same assembly as your DbContext class and then calling SetDatabaseLogFormatter in the constructor of this new class.</span></span> <span data-ttu-id="35e2b-193">예를 들어:</span><span class="sxs-lookup"><span data-stu-id="35e2b-193">For example:</span></span>  

``` csharp
public class MyDbConfiguration : DbConfiguration
{
    public MyDbConfiguration()
    {
        SetDatabaseLogFormatter(
            (context, writeAction) => new OneLineFormatter(context, writeAction));
    }
}
```  

### <a name="using-the-new-databaselogformatter"></a><span data-ttu-id="35e2b-194">새 DatabaseLogFormatter를 사용 하 여</span><span class="sxs-lookup"><span data-stu-id="35e2b-194">Using the new DatabaseLogFormatter</span></span>  

<span data-ttu-id="35e2b-195">이 새 DatabaseLogFormatter Database.Log 설정 되어 언제 든 지 이제 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-195">This new DatabaseLogFormatter will now be used anytime Database.Log is set.</span></span> <span data-ttu-id="35e2b-196">따라서 파트 1에서에서 코드를 실행 합니다. 이제 하면 다음과 같은 출력 합니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-196">So, running the code from part 1 will now result in the following output:</span></span>  

```  
Context 'BlogContext' is executing command 'SELECT TOP (1) [Extent1].[Id] AS [Id], [Extent1].[Title] AS [Title]FROM [dbo].[Blogs] AS [Extent1]WHERE (N'One Unicorn' = [Extent1].[Title]) AND ([Extent1].[Title] IS NOT NULL)'
Context 'BlogContext' is executing command 'SELECT [Extent1].[Id] AS [Id], [Extent1].[Title] AS [Title], [Extent1].[BlogId] AS [BlogId]FROM [dbo].[Posts] AS [Extent1]WHERE [Extent1].[BlogId] = @EntityKeyValue1'
Context 'BlogContext' is executing command 'update [dbo].[Posts]set [Title] = @0where ([Id] = @1)'
Context 'BlogContext' is executing command 'insert [dbo].[Posts]([Title], [BlogId])values (@0, @1)select [Id]from [dbo].[Posts]where @@rowcount > 0 and [Id] = scope_identity()'
```  

## <a name="interception-building-blocks"></a><span data-ttu-id="35e2b-197">인터 셉 션 구성 요소</span><span class="sxs-lookup"><span data-stu-id="35e2b-197">Interception building blocks</span></span>  

<span data-ttu-id="35e2b-198">지금까지 EF에서 생성 된 SQL을 기록할 DbContext.Database.Log를 사용 하는 방법을 살펴봤습니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-198">So far we have looked at how to use DbContext.Database.Log to log the SQL generated by EF.</span></span> <span data-ttu-id="35e2b-199">하지만이 코드는 비교적 씬 외관 실제로 보다 일반적인 인터 셉 션에 대 한 일부 낮은 수준의 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-199">But this code is actually a relatively thin façade over some low-level building blocks for more general interception.</span></span>  

### <a name="interception-interfaces"></a><span data-ttu-id="35e2b-200">인터 셉 션 인터페이스</span><span class="sxs-lookup"><span data-stu-id="35e2b-200">Interception interfaces</span></span>  

<span data-ttu-id="35e2b-201">인터 셉 션 코드는 인터 셉 션 인터페이스의 개념을 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-201">The interception code is built around the concept of interception interfaces.</span></span> <span data-ttu-id="35e2b-202">이러한 인터페이스 IDbInterceptor에서 상속 하 고 EF 작업을 수행할 때 호출 되는 메서드를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-202">These interfaces inherit from IDbInterceptor and define methods that are called when EF performs some action.</span></span> <span data-ttu-id="35e2b-203">의도 형식의 개체를 가로 챘 당 하나의 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-203">The intent is to have one interface per type of object being intercepted.</span></span> <span data-ttu-id="35e2b-204">예를 들어 IDbCommandInterceptor 인터페이스는 EF가 ExecuteNonQuery, ExecuteScalar, ExecuteReader, 및 관련된 메서드를 호출 하기 전에 호출 되는 메서드를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-204">For example, the IDbCommandInterceptor interface defines methods that are called before EF makes a call to ExecuteNonQuery, ExecuteScalar, ExecuteReader, and related methods.</span></span> <span data-ttu-id="35e2b-205">마찬가지로, 인터페이스는 이러한 각 작업에 완료 될 때 호출 되는 메서드를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-205">Likewise, the interface defines methods that are called when each of these operations completes.</span></span> <span data-ttu-id="35e2b-206">위에서 살펴본 DatabaseLogFormatter 클래스 명령을 기록이 인터페이스를 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-206">The DatabaseLogFormatter class that we looked at above implements this interface to log commands.</span></span>  

### <a name="the-interception-context"></a><span data-ttu-id="35e2b-207">인터 셉 션 컨텍스트</span><span class="sxs-lookup"><span data-stu-id="35e2b-207">The interception context</span></span>  

<span data-ttu-id="35e2b-208">인터셉터 인터페이스를 정의 하는 방법을 검색 하는 것은 호출할 때마다 DbInterceptionContext 형식의 개체 또는 형식 지정에서 파생 되 DbCommandInterceptionContext 같은 명백한\<\>합니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-208">Looking at the methods defined on any of the interceptor interfaces it is apparent that every call is given an object of type DbInterceptionContext or some type derived from this such as DbCommandInterceptionContext\<\>.</span></span> <span data-ttu-id="35e2b-209">이 개체는 EF 수행 되는 작업에 대 한 컨텍스트 정보를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-209">This object contains contextual information about the action that EF is taking.</span></span> <span data-ttu-id="35e2b-210">예를 들어, DbContext를 대신 하 여 작업 수행 되는 경우 DbContext는 DbInterceptionContext에 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-210">For example, if the action is being taken on behalf of a DbContext, then the DbContext is included in the DbInterceptionContext.</span></span> <span data-ttu-id="35e2b-211">마찬가지로, 비동기적으로 실행 되는 명령에 대 한 IsAsync 플래그 DbCommandInterceptionContext에 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-211">Similarly, for commands that are being executed asynchronously, the IsAsync flag is set on DbCommandInterceptionContext.</span></span>  

### <a name="result-handling"></a><span data-ttu-id="35e2b-212">결과 처리</span><span class="sxs-lookup"><span data-stu-id="35e2b-212">Result handling</span></span>  

<span data-ttu-id="35e2b-213">DbCommandInterceptionContext\< \> 클래스 결과, OriginalResult, 예외 및 OriginalException를 호출 하는 속성을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-213">The DbCommandInterceptionContext\<\> class contains a properties called Result, OriginalResult, Exception, and OriginalException.</span></span> <span data-ttu-id="35e2b-214">이러한 속성은 작업이 실행 되기 전에 호출 되는 인터 셉 션 메서드 호출에 대 한 null/0으로 설정-즉,에 대 한 합니다... 메서드를 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-214">These properties are set to null/zero for calls to the interception methods that are called before the operation is executed — that is, for the …Executing methods.</span></span> <span data-ttu-id="35e2b-215">작업이 실행 되 고 성공 하면 다음 결과 및 OriginalResult으로 설정 됩니다는 작업의 결과.</span><span class="sxs-lookup"><span data-stu-id="35e2b-215">If the operation is executed and succeeds, then Result and OriginalResult are set to the result of the operation.</span></span> <span data-ttu-id="35e2b-216">이러한 값의 작업을 실행 한 후 호출 되는 인터 셉 션 메서드에서 관찰할 수 있습니다-즉, 합니다... 메서드를 실행된 합니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-216">These values can then be observed in the interception methods that are called after the operation has executed — that is, on the …Executed methods.</span></span> <span data-ttu-id="35e2b-217">마찬가지로, 작업을 throw 하는 경우 다음 예외 및 OriginalException 속성을 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-217">Likewise, if the operation throws, then the Exception and OriginalException properties will be set.</span></span>  

#### <a name="suppressing-execution"></a><span data-ttu-id="35e2b-218">실행을 표시 하지 않기</span><span class="sxs-lookup"><span data-stu-id="35e2b-218">Suppressing execution</span></span>  

<span data-ttu-id="35e2b-219">경우 인터셉터는 명령이 실행 되기 전에 결과 속성을 설정 하는 (중 하나에... 메서드를 실행 하는) 다음 EF는 실제로 명령을 실행 하려고 하지 않습니다 하지만 결과 집합 대신 사용 하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-219">If an interceptor sets the Result property before the command has executed (in one of the …Executing methods) then EF will not attempt to actually execute the command, but will instead just use the result set.</span></span> <span data-ttu-id="35e2b-220">즉,는 인터셉터 명령 실행을 표시 하지 않을 수 있지만 명령이 실행 된 것 처럼 EF가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-220">In other words, the interceptor can suppress execution of the command but have EF continue as if the command had been executed.</span></span>  

<span data-ttu-id="35e2b-221">이 사용할 수 있는 방법의 예로 일괄 처리 명령이 래핑 공급자를 사용 하 여 일반적으로 수행 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-221">An example of how this might be used is the command batching that has traditionally been done with a wrapping provider.</span></span> <span data-ttu-id="35e2b-222">인터셉터 일괄 처리로 나중에 실행할 명령을 저장 하지만 "보안상" EF 명령을 정상적으로 실행 된 합니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-222">The interceptor would store the command for later execution as a batch but would “pretend” to EF that the command had executed as normal.</span></span> <span data-ttu-id="35e2b-223">Note는 일괄 처리를 구현 하려면 이보다 더 필요 하지만 변경 인터 셉 션 결과 사용할 수 있는 방법의 예제입니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-223">Note that it requires more than this to implement batching, but this is an example of how changing the interception result might be used.</span></span>  

<span data-ttu-id="35e2b-224">실행 중에 Exception 속성을 설정 하 여도 무시 될 수는 중... 메서드를 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-224">Execution can also be suppressed by setting the Exception property in one of the …Executing methods.</span></span> <span data-ttu-id="35e2b-225">이렇게 하면 지정 된 예외를 throw 하 여 작업의 실행이 실패 했습니다 처럼 계속 하는 EF 합니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-225">This causes EF to continue as if execution of the operation had failed by throwing the given exception.</span></span> <span data-ttu-id="35e2b-226">이 수를 당연히 응용 프로그램 충돌을 않지만 일시적인 예외 또는 일부 기타 예외가 EF에서 처리 되는 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-226">This may, of course, cause the application to crash, but it may also be a transient exception or some other exception that is handled by EF.</span></span> <span data-ttu-id="35e2b-227">예를 들어이 사용할 수 있습니다 테스트 환경에서 명령 실행이 실패 하는 경우 응용 프로그램의 동작을 테스트 하려면.</span><span class="sxs-lookup"><span data-stu-id="35e2b-227">For example, this could be used in test environments to test the behavior of an application when command execution fails.</span></span>  

#### <a name="changing-the-result-after-execution"></a><span data-ttu-id="35e2b-228">실행 후 결과 변경합니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-228">Changing the result after execution</span></span>  

<span data-ttu-id="35e2b-229">경우 인터셉터는 명령 실행 후 결과 속성을 설정 하는 (중 하나에... 메서드 실행) EF 변경된 결과 사용 하 여 실제로 작업에서 반환 된 결과 대신 됩니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-229">If an interceptor sets the Result property after the command has executed (in one of the …Executed methods) then EF will use the changed result instead of the result that was actually returned from the operation.</span></span> <span data-ttu-id="35e2b-230">마찬가지로, 명령이 실행 후 예외 속성을 설정 하는 인터셉터를 하는 경우 다음 EF 예외를 throw 합니다를 집합으로 작업 예외를 throw 했습니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-230">Similarly, if an interceptor sets the Exception property after the command has executed, then EF will throw the set exception as if the operation had thrown the exception.</span></span>  

<span data-ttu-id="35e2b-231">인터셉터 없는 예외를 throw 해야를 나타내기 위해 null로 Exception 속성을 설정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-231">An interceptor can also set the Exception property to null to indicate that no exception should be thrown.</span></span> <span data-ttu-id="35e2b-232">이 작업을 실행 하지 못했지만 인터셉터가 계속 작업이 성공한 것 처럼 EF 경우 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-232">This can be useful if execution of the operation failed but the interceptor wishes EF to continue as if the operation had succeeded.</span></span> <span data-ttu-id="35e2b-233">일반적으로 또한 여기에 EF에서 일부 결과 값으로 계속 작업할 수 있도록 결과 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-233">This usually also involves setting the Result so that EF has some result value to work with as it continues.</span></span>  

#### <a name="originalresult-and-originalexception"></a><span data-ttu-id="35e2b-234">OriginalResult 및 OriginalException</span><span class="sxs-lookup"><span data-stu-id="35e2b-234">OriginalResult and OriginalException</span></span>  

<span data-ttu-id="35e2b-235">EF는 작업 실행 후 예외를 사용 하 여 실행에 실패 한 실행을 실패 하지 않은 경우의 결과 및 OriginalResult 속성 또는 예외 및 OriginalException 속성을 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-235">After EF has executed an operation it will set either the Result and OriginalResult properties if execution did not fail or the Exception and OriginalException properties if execution failed with an exception.</span></span>  

<span data-ttu-id="35e2b-236">OriginalResult 및 OriginalException 속성을 읽기 전용 이며만 실제로 작업을 실행 한 후 EF에서 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-236">The OriginalResult and OriginalException properties are read-only and are only set by EF after actually executing an operation.</span></span> <span data-ttu-id="35e2b-237">인터셉터에서 이러한 속성을 설정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-237">These properties cannot be set by interceptors.</span></span> <span data-ttu-id="35e2b-238">이 모든 인터셉터는 예외 또는 실제 예외 대신 일부 다른 인터셉터가 설정 된 결과 나 작업이 실행 될 때 발생 한 결과 구분할 수는 것을 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-238">This means that any interceptor can distinguish between an exception or result that has been set by some other interceptor as opposed to the real exception or result that occurred when the operation was executed.</span></span>  

### <a name="registering-interceptors"></a><span data-ttu-id="35e2b-239">인터셉터를 등록합니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-239">Registering interceptors</span></span>  

<span data-ttu-id="35e2b-240">인터 셉 션 인터페이스 중 하나 이상을 구현 하는 클래스 만들어지면 DbInterception 클래스를 사용 하 여 EF를 사용 하 여 등록할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-240">Once a class that implements one or more of the interception interfaces has been created it can be registered with EF using the DbInterception class.</span></span> <span data-ttu-id="35e2b-241">예를 들어:</span><span class="sxs-lookup"><span data-stu-id="35e2b-241">For example:</span></span>  

``` csharp
DbInterception.Add(new NLogCommandInterceptor());
```  

<span data-ttu-id="35e2b-242">인터셉터는 DbConfiguration 코드 기반 구성 메커니즘을 사용 하 여 응용 프로그램 도메인 수준에서 등록할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-242">Interceptors can also be registered at the app-domain level using the DbConfiguration code-based configuration mechanism.</span></span>  

### <a name="example-logging-to-nlog"></a><span data-ttu-id="35e2b-243">예: NLog에 로깅</span><span class="sxs-lookup"><span data-stu-id="35e2b-243">Example: Logging to NLog</span></span>  

<span data-ttu-id="35e2b-244">보겠습니다이 모든 예제를 사용 하 여 해당 IDbCommandInterceptor 및 [NLog](http://nlog-project.org/) 하려면:</span><span class="sxs-lookup"><span data-stu-id="35e2b-244">Let’s put all this together into an example that using IDbCommandInterceptor and [NLog](http://nlog-project.org/) to:</span></span>  

- <span data-ttu-id="35e2b-245">비 비동기적으로 실행 되는 모든 명령에 대 한 경고를 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-245">Log a warning for any command that is executed non-asynchronously</span></span>  
- <span data-ttu-id="35e2b-246">실행 될 때 throw 되는 모든 명령에 대 한 오류를 기록</span><span class="sxs-lookup"><span data-stu-id="35e2b-246">Log an error for any command that throws when executed</span></span>  

<span data-ttu-id="35e2b-247">위에 표시 된 대로 등록 해야 하는 로깅을 수행 하는 클래스는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-247">Here’s the class that does the logging, which should be registered as shown above:</span></span>  

``` csharp
public class NLogCommandInterceptor : IDbCommandInterceptor
{
    private static readonly Logger Logger = LogManager.GetCurrentClassLogger();

    public void NonQueryExecuting(
        DbCommand command, DbCommandInterceptionContext<int> interceptionContext)
    {
        LogIfNonAsync(command, interceptionContext);
    }

    public void NonQueryExecuted(
        DbCommand command, DbCommandInterceptionContext<int> interceptionContext)
    {
        LogIfError(command, interceptionContext);
    }

    public void ReaderExecuting(
        DbCommand command, DbCommandInterceptionContext<DbDataReader> interceptionContext)
    {
        LogIfNonAsync(command, interceptionContext);
    }

    public void ReaderExecuted(
        DbCommand command, DbCommandInterceptionContext<DbDataReader> interceptionContext)
    {
        LogIfError(command, interceptionContext);
    }

    public void ScalarExecuting(
        DbCommand command, DbCommandInterceptionContext<object> interceptionContext)
    {
        LogIfNonAsync(command, interceptionContext);
    }

    public void ScalarExecuted(
        DbCommand command, DbCommandInterceptionContext<object> interceptionContext)
    {
        LogIfError(command, interceptionContext);
    }

    private void LogIfNonAsync<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
        if (!interceptionContext.IsAsync)
        {
            Logger.Warn("Non-async command used: {0}", command.CommandText);
        }
    }

    private void LogIfError<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
        if (interceptionContext.Exception != null)
        {
            Logger.Error("Command {0} failed with exception {1}",
                command.CommandText, interceptionContext.Exception);
        }
    }
}
```  

<span data-ttu-id="35e2b-248">명령을 비 비동기적으로 실행 되는 경우를 검색 하 고 명령을 실행 하는 오류가 있을 때 발견 하이 코드는 인터 셉 션 컨텍스트를 사용 하는 방법을 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="35e2b-248">Notice how this code uses the interception context to discover when a command is being executed non-asynchronously and to discover when there was an error executing a command.</span></span>  
